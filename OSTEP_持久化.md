# Ch36 I/O设备

深入讲解持久性部分的主要内容之前, 先介绍输入/输入(I/O)设备的概念,并展示操作系统如何与它们交互.当然,I/O 对计算机系统非常重要.

关键问题：如何将 I/O 集成进计算机系统中
I/O 应该如何集成进系统中？其中的一般机制是什么？如何让它们变得高效? 

## 36.1 系统架构

先看一个典型系统的架构(见图 36.1).图片显示了一个单一的CPU通过某种内存总线或互连连接到系统的主存.一些设备通过通用I/O总线, 在许多现代系统里称为PCI(或者它的一种衍生如PCIe). 显卡和一些其他高性能I/O设备就是在这上面.
最后最下面的是一条或多条外部总线, 如SCSI, SATA, USB等. 他们把慢速设备连接到系统, 包括磁盘, 鼠标和键盘等.

![](assets/Pasted%20image%2020230410004301.png)

你可能会问：为什么要用这样的分层架构？ 简单回答：因为物理布局及造价成本.
越快的总线必越短, 因此高性能的内存总线没有足够的空间连接太多设备. 另外,在工程上高性能总线的造价非常高.

所以, 系统的设计采用了这种分层的方式, 这样可以让要求高性能的设备(比如显卡)离CPU更近一些, 低性能的设备离CPU远一些. 将磁盘和其他低速设备连到外围总线的好处很多, 其中较为突出的好处就是你可以在外围总线上连接大量的设备. 

当然, 现代系统越来越多使用专用芯片组和更快的点对点的互连来提升性能. 图36.2展示了一个因特尔Z270芯片组的大概框架. 最上层, 与CPU连接最近的是内存系统, 还有高性能的显卡来支持游戏和其他图形密集的应用.

![](assets/Pasted%20image%2020230410005743.png)

CPU通过英特尔专有的DMI(Direct Media Interface)与一个I/O 芯片连接. 剩下的设备都通过许多不同的连接与这个芯片相连. 右边, 一个或多个硬盘通过eSATA接口与系统相连. 
ATA (AT附件, 指提供与IBM PC AT的连接), 然后是SATA (针对串行ATA), 现在是 eSATA (针对外部 SATA), 代表了过去几十年存储接口的演变, 每一步都在提高性能, 以跟上现代存储设备的步伐. 

I/O芯片下边是许多UBS(Universal Serial Bus, 通用串行总线) 连接, 在此描述中, 使键盘和鼠标连接到电脑. 在许多现代系统上, USB被用在像这些低性能的设备.

最后, 左边, 其他高性能设备可以通过PCIe(Peripheral Component Interconnect Express 外围组件快速互连) 连接到系统. 在这个图里, 一个网络接口在这里与系统相连. 高性能存储设备(比如NVMe持久存储设备) 也经常连接在这.

## 36.2 标准设备

现在来看一个标准设备(不是真的), 通过它来帮助我们更好地理解设备高效交互的机制. 从图 36.3 中,可以看到一个包含两部分重要组件的设备.

![](assets/Pasted%20image%2020230410011539.png)

第一部分是向系统其他部分展现的硬件接口(interface).同软件一样, 硬件也需要展现某种接口,让系统软件来控制它的操作.因此, 所有设备都有某种特定接口和典型交互的协议.

任何设备的第二部分就是它的内部结构(internal structure), 这部分包含设备相关的特定实现,负责
具体实现设备展示给系统的抽象接口.非常简单的设备通常用一个或几个芯片来实现它们的功能.
更复杂的设备会包含简单的 CPU、一些通用内存、设备相关的特定芯片,来完成它们的工作.例如,现代 RAID 控制器通常包含成百上千行固件(firmware,即硬件设备中的软件),以实现其功能.

## 36.3 标准协议

在图36.3中, 一个(简化的)设备接口包含 3 个寄存器：一个状态(status)寄存器,可以读取并查看设备的当前状态；一个命令(command)寄存器,用于通知设备执行某个具体任务；一个数据(data)寄存器,将数据传给设备或从设备接收数据.通过读写这些寄存器,操作系统可以控制设备的行为.

我们现在来描述操作系统与该设备的典型交互,以便让设备为它做某事.协议如下：
```c
While (STATUS == BUSY)
	; // wait until device is not busy
Write data to DATA register
Write command to COMMAND register
	(Doing so starts the device and executes the command)
While (STATUS == BUSY)
	; // wait until device is done with your request
```

该协议包含 4 步:

- 第 1 步,操作系统通过反复`读取状态寄存器`,等待设备进入可以接收命令的就绪状态.我们称之为轮询(polling)设备(基本上,就是问它正在做什么).
- 第 2 步,操作系统下发`数据`到数据寄存器.例如,你可以想象如果这是一个磁盘,需要多次写入操作,将一个磁盘块(比如 4KB)传递给设备.如果主 CPU 参与数据移动(就像这个示例协议一样),我们就称之为编程的 I/O(programmed I/O,PIO).
- 第 3 步,操作系统将`命令`写入命令寄存器；这样设备就知道数据已经准备好了,它应该开始执行命令.
- 最后一步,操作系统再次通过不断轮询设备,等待并判断设备是否执行完成命令(有可能得到一个指示成功或失败的错误码).

这个简单的协议好处是足够`简单并且有效`.但是难免会有一些`低效`和`不方便`.我们注意到这个协议存在的第一个问题就是`轮询过程比较低效`,在等待设备执行完成命令时浪费大量 CPU 时间,如果此时操作系统可以切换执行下一个就绪进程,就可以大大提高 CPU 的利用率.

关键问题：如何减少轮询开销
操作系统检查设备状态时如何避免频繁轮询,从而降低管理设备的 CPU 开销？

## 36.4 利用中断减少 CPU 开销

多年前,工程师们发明了我们目前已经很常见的`中断(interrupt)`来减少 CPU 开销.
有了中断后,CPU 不再需要不断轮询设备,而是向设备发出一个请求,然后就可以让对应进程睡眠,切换执行其他任务.
当设备完成了自身操作, 会`抛出一个硬件中断`, 引发 CPU 跳转执行操作系统预先定义好的`中断服务程序`(Interrupt Service Routine, ISR), 或更为简单的中断处理程序(interrupt handler). 

中断处理程序是一小段操作系统代码, 它会结束之前的请求(比如从设备读取到了数据或者错误码)并且唤醒等待 I/O 的进程继续执行.

因此,中断允许计算与 I/O 重叠(overlap),这是提高 CPU 利用率的关键.下面的时间线展示了这一点：

![](assets/Pasted%20image%2020230410013018.png)

其中,进程 1 在 CPU 上运行一段时间(对应 CPU 那一行上重复的 1),然后发出一个读取数据的 I/O 请求给磁盘.如果没有中断,那么操作系统就会简单自旋,不断轮询设备状态,直到设备完成 I/O 操作(对应其中的 p).当设备完成请求的操作后,进程 1 又可以继续运行.

如果我们利用中断并允许重叠,操作系统就可以在等待磁盘操作时做其他事情：
![](assets/Pasted%20image%2020230410013215.png)

在这个例子中,在磁盘处理进程 1 的请求时,操作系统在 CPU 上运行进程 2.磁盘处理完成后,触发一个中断,然后操作系统唤醒进程 1 继续运行.这样,在这段时间,无论CPU 还是磁盘都可以有效地利用.

注意,使用中断并非总是最佳方案.假如有一个非常高性能的设备,它处理请求很快：通常在 CPU 第一次轮询时就可以返回结果.此时如果使用中断,反而会使系统变慢：切换到其他进程,处理中断,再切换回之前的进程代价不小.

因此,如果`设备非常快`, 那么最好的办法反而是`轮询`. 如果`设备比较慢`, 那么采用允许发生重叠的`中断`更好. 如果设备的速度未知, 或者时快时慢, 可以考虑使用`混合(hybrid)策略`,先尝试轮询一小段时间,如果设备没有完成操作,此时再使用中断.这种两阶段(two-phased)的办法可以实现两种方法的好处.

> 提示：中断并非总是比 PIO 好
> 尽管中断可以做到计算与I/O的重叠, 但这`仅在慢速设备`上有意义. 否则, 额外的中断处理和上下文切换的代价反而会超过其收益. 另外, 如果短时间内出现大量的中断, 可能会使得系统过载并且引发活锁. 这种情况下, 轮询的方式可以在操作系统自身的调度上提供更多的控制, 反而更有效.

另一个最好`不要使用中断`的场景是`网络`.  网络端收到大量数据包,如果每一个包都发生一次中断,那么有可能导致操作系统发生活锁(livelock),即不断处理中断而无法处理用户层的请求.
例如,假设一个 Web 服务器因为“点杠效应”而突然承受很重的负载.这种情况下,偶尔使用轮询的方式可以更好地控制系统的行为,并允许 Web 服务器先服务一些用户请求,再回去检查网卡设备是否有更多数据包到达.

另一个`基于中断的优化`就是合并(coalescing).设备在抛出中断之前往往会等待一小段时间,在此期间,其他请求可能很快完成,因此多次中断可以合并为一次中断抛出,从而降低处理中断的代价.当然,等待太长会增加请求的延迟,这是系统中常见的折中.

## 36.5 利用 DMA 进行更高效的数据传送

标准协议还有一点需要我们注意.具体来说,如果使用`编程的I/O`将一大块数据传给设备,CPU 又会因为琐碎的任务而变得负载很重,浪费了时间和算力,本来更好是用于运行其他进程.下面的时间线展示了这个问题：
![](assets/Pasted%20image%2020230410013758.png)

进程 1 在运行过程中需要向磁盘写一些数据, 然后, 它启动I/O, 必须显式地将数据从内存复制到设备, 一次一个字长(在图中标记为 c).拷贝结束后, 磁盘上的 I/O 操作开始执行,此时 CPU 才可以处理其他请求.

关键问题：如何减少 PIO 的开销
使用 PIO 的方式,CPU 的时间会浪费在向设备传输数据或从设备传出数据的过程中.如何才能分
离这项工作,从而提高 CPU 的利用率？

解决方案就是使用 DMA(Direct Memory Access).DMA引擎是系统中的一个特殊设备, 它可以协调完成内存和设备间的数据传递, 不需要CPU介入.

DMA 工作过程如下.为了能够将数据传送给设备, 操作系统会`通过编程`告诉DMA引擎 数据在内存的位置, 要拷贝的大小以及要拷贝到哪个设备.这时候OS就完成了它的活, 可以去处理别的工作了. 
当 DMA完成了, DMA控制器会抛出一个中断, 然后OS因此就知道了传输完成了. 时间线如下: 

![](assets/Pasted%20image%2020230410015031.png)

从时间线中可以看到,`数据的拷贝工作`都是由 `DMA 控制器`来完成的.因为 CPU 在此时是空闲的,所以操作系统可以让它做一些其他事情,比如此处调度进程 2 到 CPU 来运行.因此进程 2 在进程 1 再次运行之前可以使用更多的 CPU.

## 36.6 与设备交互的方式

现在, 我们了解了执行I/O涉及的效率问题后, 还有其他一些问题需要解决, 以便将设备合并到系统中. 我们还没有真正讨论过操作系统究竟如何与设备进行通信！所以问题如下.

关键问题：如何与设备通信
硬件如何如与设备通信？是否需要一些明确的指令？或者其他的方式？

主要有两种方式来实现与设备的交互:

- 第一种办法相对老一些(在 IBM 主机中使用了多年),就是用`明确的 I/O 指令`.这些指令规定了操作系统将数据发送到特定设备寄存器的方法,从而允许构造上文提到的协议.

例如在 x86 上,`in 和 out 指令`可以用来与设备进行交互.当需要发送数据给设备时,调用者指定一个存入数据的特定寄存器及一个代表设备的特定端口.执行这个指令就可以实现期望的行为.

这些指令通常是`特权指令(privileged)`.`操作系统是唯一`可以直接与设备交互的实体.例如,设想如果任意程序都可以直接读写磁盘：会完全混乱(一定会),因为任何用户程序都可以利用这个漏洞来取得计算机的全部控制权.

- 第二种方法是`内存映射 I/O`(memory-mapped I/O). 通过这种方式, 将`硬件设备寄存器`作为内存地址用.当需要访问设备寄存器时, 操作系统装载(读取)或者存入(写入)到该内存地址; 然后硬件会将装载/存入转移到设备上, 而不是物理内存. 

两种方法没有一种具备极大的优势. 内存映射 I/O 的好处是不需要引入新指令来实现设备交互, 但两种方法今天都在使用. 

> 总结就是: 要么独立编址, 用独立的I/O指令; 要么统一编址, 把I/O设备当内存用.

## 36.7 纳入操作系统: 设备驱动程序

最后我们要讨论一个问题: 每个设备都有非常特定的接口, 如何将它们纳入操作系统. 而我们希望操作系统尽可能通用. 例如文件系统,我们希望开发一个文件系统可以工作在SCSI 硬盘、IDE 硬盘、USB 钥匙串设备等设备之上,并且希望这个文件系统`不那么清楚对`这些不同设备发出读写请求的全部细节.因此,我们的问题如下.

关键问题：如何实现一个设备无关的操作系统
如何保持操作系统的大部分与设备无关,从而对操作系统的主要子系统隐藏设备交互的细节？

这个问题可以通过古老的抽象(abstraction)技术来解决.
在最底层,操作系统的一部分软件清楚地知道设备如何工作,我们将这部分软件称为`设备驱动程序`(device driver),所有设备交互的细节都封装在其中.

我们来看看 Linux 文件系统栈,理解抽象技术如何应用于操作系统的设计和实现.图
36.4 粗略地展示了 Linux 软件的组织方式.

![](assets/Pasted%20image%2020230410021319.png)

可以看出,文件系统(包括上面的应用层)完全不清楚它使用的是什么类型的磁盘.它只需要简单地向通用块设备层发送读写请求即可,块设备层会将这些请求路由给对应的设备驱动,然后设备驱动来完成真正的底层操作.尽管比较简单,但图展示了这些细节如何对操作系统的上层进行隐藏.

该图还显示了设备的原始接口,该接口允许特殊应用程序(如后面描述的文件系统检查器或磁盘碎片整理工具)不使用文件抽象来直接读写块.大多数系统都提供这种接口, 来支持那些底层存储管理应用.

注意,这种封装也有不足的地方.例如,如果有一个设备可以提供很多特殊的功能,但为了兼容大多数操作系统它不得不提供一个通用的接口,这样就使得自身的特殊功能无法使用.这种情况在使用 SCSI 设备的 Linux 中就发生了.

SCSI 设备提供非常丰富的报告错误信息,但其他的块设备(比如 ATA/IDE)只提供非常简单的报错处理,这样上层的所有软件只能在出错时收到一个通用的 EIO 错误码(一般 IO 错误),SCSI 可能提供的所有附加信息都不能报告给文件系统.

有趣的是,因为所有需要插入系统的设备都需要安装对应的驱动程序,所以久而久之,驱动程序的代码在整个内核代码中的占比越来越大.查看 Linux 内核代码会发现,超过 70%的代码都是各种驱动程序.在 Windows 系统中,这样的比例同样很高.因此,如果有人跟你说操作系统包含上百万行代码,实际的意思是包含上百万行驱动程序代码.

当然, 任何安装进操作系统的驱动程序, 大部分默认都不是激活状态(只有一小部分设备是在系统刚开启时就需要连接). 因为驱动程序的开发者大部分是“业余的”(不是全职内核开发者), 所以他们更容易写出缺陷, 因此是内核崩溃的主要贡献者.

## 36.8 案例研究：简单的 IDE 磁盘驱动程序

为了更深入地了解设备驱动,我们快速看看一个真实的设备——IDE 磁盘驱动程序.我们总结了协议, 也会看看 xv6 源码中一个简单的、能工作的 IDE 驱动程序实现.

DE 硬盘暴露给操作系统的接口比较简单,包含 4 种类型的寄存器,即控制、命令块、状态和错误.在 x86 上,利用 I/O 指令 in 和 out 向特定的 I/O 地址(如下面的 0x3F6)读取或写入时,可以访问这些`寄存器`,如图 36.5 所示.

![](assets/Pasted%20image%2020230410022655.png)

下面是与设备交互的简单协议,假设它已经初始化了. 
- 等待驱动就绪.读取状态寄存器(0x1F7)直到驱动 READY 而非忙碌.
- 向命令寄存器写入参数.写入扇区数,待访问扇区对应的逻辑块地址(LBA),并将驱动编号(master=0x00,slave=0x10,因为 IDE 允许接入两个硬盘)写入命令寄存器(0x1F2-0x1F6).
- 开启 I/O.发送读写命令到命令寄存器.向命令寄存器(0x1F7)中写入 READ-WRITE命令.
- 数据传送(针对写请求)：等待直到驱动状态为 READY 和 DRQ(驱动请求数据),向数据端口写入数据.
- 中断处理.在最简单的情况下,每个扇区的数据传送结束后都会触发一次中断处理程序.较复杂的方式支持批处理,全部数据传送结束后才会触发一次中断处理. 
- 错误处理.在每次操作之后读取状态寄存器.如果 ERROR 位被置位,可以读取错误寄存器来获取详细信息.

![](assets/Pasted%20image%2020230410023133.png)

该协议的大部分可以在 xv6 的 IDE 驱动程序中看到,它(在初始化后)通过 4 个主要函数来实现.
第一个是 ide_rw(),它会将一个请求加入队列(如果前面还有请求未处理完成),或者直接将请求发送到磁盘(通过 ide_start_request()).不论哪种情况,调用进程进入睡眠状态,等待请求处理完成.
第二个是 ide_start_request(),它会将请求发送到磁盘(在写请求时,可能是发送数据).此时 x86 的 in 或 out 指令会被调用,以读取或写入设备寄存器.
在发起请求之前,开始请求函数会使用第三个函数 ide_wait_ready(),来确保驱动处于就绪状态.
最后,当发生中断时,ide_intr()会被调用.它会从设备中读取数据(如果是读请求),并且在结束后唤醒等待的进程,如果此时在队列中还有别的未处理的请求,则调用ide_start_request()接着处理下一个 I/O 请求.

## 36.9 历史记录

在结束之前,我们简述一下这些基本思想的由来.

中断的思想很古老,存在于最早的机器之中.例如,20 世纪 50 年代的 UNIVAC 上就有某种形式的中断向量.

在 20 世纪 50 年代中期,就有系统的 I/O 设备可以直接和内存交互,并在完成后中断 CPU.

中断、DMA 及相关思想都是在快速 CPU 和慢速设备之间权衡的结果.

## 36.10 小结

标准设备也有其硬件接口, 和内部结构.  

通过设备的硬件寄存器就(状态, 命令, 数据三种寄存器)可以控制设备. 

最初的标准协议, 是CPU轮询来控制设备. 但这种方式很浪费CPU性能, 于是出现了中断的形式. 
CPU启动I/O操作之后, 给设备下命令(状态, 命令, 数据寄存器), 该进程就被阻塞, 切换到别的进程去执行. 同时I/O开始工作, 完成之后, 给CPU发送中断, 然后CPU通过中断处理程序来处理.

CPU需要自己把数据从内存拷贝到设备的寄存器中, 这也比较浪费CPU性能. 于是出现了 DMA, CPU下命令后, DMA就负责设备和内存之间数据传输, 不用CPU过问, CPU就可以继续执行工作. 完成之后, DMA给CPU发送中断.

CPU与设备交互的方式有两种: 要么独立编址, 用独立的I/O指令; 要么统一编址, 把I/O设备寄存器当内存用. 

设备驱动程序, 内核的细节对上层 层层封装, 从而更容易以无关具体设备的方式构建操作系统的其余部分.

# Ch37 磁盘驱动器

介绍完 I/O 设备的一般概念, 展示了操作系统如何与这种东西进行交互. 将更详细地介绍一种设备：磁盘驱动器(hard disk drive).
这些驱动器一直是计算机系统中持久数据存储的主要形式,文件系统技术的大部分发展都是基于它们的行为.
因此,在构建管理它的文件系统软件之前,有必要先了解磁盘操作的细节.

关键问题：如何存储和访问磁盘上的数据
现代磁盘驱动器如何存储数据？接口是什么？数据是如何安排和访问的？磁盘调度如何提高性能？

## 37.1 接口

先来了解一个现代磁盘驱动器的接口. 所有现代驱动器的基本接口都很简单. 

驱动器由大量`扇区`(512 字节块)组成, 每个扇区都可以读取或写入. 在具有n个扇区的磁盘上, 扇区从0到n-1编号. 因此, 我们可以`将磁盘视为一组扇区`, 0到n-1是`驱动器的地址空间`(address space). 

多扇区操作是可能的. 实际上, 许多文件系统一次读取或写入4KB(或更多). 但是, 在更新磁盘时, 驱动器制造商唯一保证的是`单个512字节的写入`是`原子的`(atomic, 即它将完整地完成或者根本不会完成). 因此, 如果发生不合时宜的掉电, 则只能完成大量写入的一部分, (有时称为不完整写入(torn write) ). 

大多数磁盘驱动器的客户端都会做出一些假设, 但这些假设并未直接在接口中指定. 
具体来说, 通常可以假设访问驱动器地址空间内`两个彼此靠近的块`将比访问两个相隔很远的块`更快`. 人们通常也可以`假设访问连续块`(即顺序读取或写入)是`最快的访问模式`, 并且通常比任何更随机的访问模式快得多. 

## 37.2 基本几何形状

现代磁盘的一些组件.  我们从一个盘片(platter)开始. 它是一个圆形坚硬的表面, 通过引入磁性变化来永久存储数据. 磁盘可能有一个或多个盘片. 每个盘片有两面, 每面都称为表面. 这些盘片通常由一些硬质材料(如铝)制成, 然后涂上薄薄的`磁性层`, 即使驱动器断电, 驱动器也能持久存储数据位. 

所有盘片都围绕主轴(spindle)连接在一起,主轴连接到一个电机,以一个恒定(固定)的速度旋转盘片(当驱动器接通电源时).旋转速率通常以每分钟转数(Rotations Per Minute,RPM)来测量,典型的现代数值在 7200～15000 RPM 范围内.请注意,我们经常会对单次旋转的时间感兴趣,例如,以 10000 RPM 旋转的驱动器意味着一次旋转需要大约 6ms.

数据在扇区的同心圆中的每个表面上被编码.我们称这样的同心圆为一个磁道(track).一个表面包含数以千计的磁道,紧密地排在一起,数百个磁道只有头发的宽度.

要从表面进行读写操作, 我们需要一种机制, 使我们能够即读取磁盘上的磁性, 或者让它们发生变化(即写入). 读写过程由磁头(disk head)完成；驱动器的每个表面有一个这样的磁头.磁头连接到单个磁盘臂(disk arm)上,磁盘臂在表面上移动,将磁头定位在期望的磁道上. 

## 37.3 简单的磁盘驱动器

让我们每次构建一个磁道的模型, 来了解磁盘是如何工作的. 假设我们有一个单一磁道的简单磁盘. 
(如图37.1)
![](assets/Pasted%20image%2020230410130350.png)

该磁道只有12个扇区, 每个扇区的大小为512字节, 因此用0到11的数字表示. 这里的单个盘片围绕主轴旋转, 电机连接到主轴. 当然, 磁道本身并不太有趣, 我们希望能够读取或写入这些扇区, 因此需要一个连接到磁盘臂上的磁头 ,如我们现在所见(见图 37.2).

![](assets/Pasted%20image%2020230410130515.png)

在图37.2中, 连接到磁盘臂末端的磁头位于扇形部分 6 的上方, 磁盘表面逆时针旋转. 

### 单磁道延迟: 旋转延迟

要理解如何在简单的单道磁盘上处理请求,请想象我们现在收到读取块 0 的请求.磁盘应如何处理该请求？

在我们的简单磁盘中, 磁盘不必做太多工作. 具体来说, 它必须等待期望的扇区旋转到磁头下. 这种等待在现代驱动器中经常发生, 并且是I/O服务时间的重要组成部分, 它有一个特殊的名称: 旋转延迟(rotational delay, 有时称为 rotation delay).

在这个例子中, 如果完整的旋转延迟是R, 那么磁盘必然产生大约为R/2的旋转延迟, 以等待0来到读/写磁头下面(如果我们从6开始). 对这个单一磁道, 最坏情况的请求是第5扇区, 这导致接近完整的旋转延迟, 才能服务这种请求.

### 多磁道：寻道时间

到目前为止, 我们的磁盘只有一条磁道, 这是不太现实的. 现代磁盘当然有数以百万计的磁道. 因此, 我们来看看更具现实感的磁盘表面, 这个表面有3条磁道(见图 37.3 左图). 

在该图中, 磁头当前位于最内圈的磁道上(它包含扇区 24～35). 下一个磁道包含下一组扇区(12～23), 最外面的磁道包含最前面的扇区(0～11). 

![](assets/Pasted%20image%2020230410133226.png)

为了理解驱动器如何访问给定的扇区, 我们现在追踪请求发生在远处扇区的情况, 例如, 读取扇区 11. 为了服务这个读取请求, 驱动器必须首先将磁盘臂移动到正确的磁道(在这种情况下, 是最外面的磁道), 通过一个所谓的`寻道(seek)`过程. 寻道, 以及旋转, 是最昂贵的磁盘操作之一. 

应该指出的是,寻道有许多阶段：首先是磁盘臂移动时的加速阶段.然后随着磁盘臂全速移动而惯性滑动.然后随着磁盘臂减速而减速.最后,在磁头小心地放置在正确的磁道上时停下来.停放时间(settling time)通常不小, 例如0.5～2ms, 因为驱动器必须确定找到正确的磁道. 

寻道之后, 磁盘臂将磁头定位在正确的磁道上. 图37.3(右图)描述了寻道. 

在寻道过程中, 磁盘臂已经移动到所需的磁道上, 并且盘片当然已经开始旋转, 在这个例子中, 大约旋转了3个扇区. 因此, 扇区9即将通过磁头下方, 我们只能承受短暂的转动延迟, 以便完成传输. 

当扇区11经过磁盘磁头时, I/O 的最后阶段将发生, 称为传输(transfer), 数据从表面读取或写入表面. 因此, 我们得到了完整的I/O时间图: 首先寻道, 然后等待转动延迟, 最后传输.

### 一些其他细节

任何现代磁盘驱动器都有一个重要组成部分,即它的缓存(cache),由于历史原因有时称为磁道缓冲区(track buffer).该缓存只是少量的内存(通常大约 8MB 或 16MB),驱动器可以使用这些内存来保存从磁盘读取或写入磁盘的数据.例如,当从磁盘读取扇区时,驱动器可能决定读取该磁道上的所有扇区并将其缓存在其存储器中.这样做可以让驱动器快速响应所有后续对同一磁道的请求.

在写入时,驱动器面临一个选择：它应该在将数据放入其内存之后,还是写入实际写
入磁盘之后,回报写入完成？前者被称为后写(write back)缓存(有时称为立即报告,immediate reporting),后者则称为直写(write through).后写缓存有时会使驱动器看起来“更快”,但可能有危险.如果文件系统或应用程序要求将数据按特定顺序写入磁盘以保证正确性,后写缓存可能会导致问题.


# Ch39 插叙:文件和目录

到目前为止, 我们看到了两项关键操作系统技术的发展: 进程, 它是虚拟化的 CPU；地址空间,它是虚拟化的内存. 在这两种抽象共同作用下,程序运行时就好像它在自己的私有独立世界中一样,好像它有自己的处理器(或多处理器),好像它有自己的内存.这种假象使得对系统编程变得更容易, 因此现在不仅在台式机和服务器上盛行, 而且在所有可编程平台上越来越普遍, 包括手机等在内. 

在这一部分. 我们加上虚拟化拼图中更关键的一块: 持久存储(persistent storage). 永久存储设备永久地(或至少长时间地)存储信息, 如传统硬盘驱动器(hard disk drive)或更现代的固态存储设备(solid-state storage device). 持久存储设备与内存不同. 内存在断电时, 其内容会丢失, 而持久存储设备会保持这些数据不变. 因此, 操作系统必须特别注意这样的设备: 用户用它们保存真正关心的数据. 

关键问题：如何管理持久存储设备
操作系统应该如何管理持久存储设备？都需要哪些 API？实现有哪些重要方面？

接下来几章会讨论管理持久数据的一些关键技术, 重点是如何提高`性能`及`可靠性`. 但是, 我们先从总体上看看 API: 你在与 UNIX 文件系统交互时会看到的接口. 

## 39.1 文件和目录

`存储虚拟化`形成了`两个关键的抽象` : 

第一个是`文件(file)`. 文件就是一个`线性字节数组`, 每个字节都可以读取或写入. 每个文件都有某种低级(底层)名称(low-level name), 通常是某种数字. 用户通常不知道这个名字(我们稍后会看到). 由于历史原因, 文件的底层名称通常称为inode号(inode number). 我们将在以后的章节中学习更多关于inode的知识.现在,只要假设每个文件都有一个与其关联的 inode 号.

在大多数系统中, 操作系统不太了解文件的结构(例如, 它是图片, 文本文件还是C代码). 相反, 文件系统的责任仅仅是将这些数据永久存储在磁盘上, 并确保当你再次请求数据时, 得到你原来放在那里的内容. 做到这一点并不像看起来那么简单!

第二个抽象是`目录(directory)`. 一个目录, 像一个文件一样, 也有一个底层名字(即inode号), 但是它的内容非常具体: 它包含 `用户可读名字, 底层名字`对的一个列表.

例如, 假设存在一个低级别名称为“10”的`文件`, 它的用户可读的名称为“foo”. `“foo”所在的目录`因此会有`条目`(“foo”, “10”), 将`用户可读名称映射到低级名称`. 

`目录中的每个条目`都`指向文件或其他目录.` 通过`将目录放入其他目录`中, 用户可以构建任意的`目录树`(directory tree, 或目录层次结构, directory hierarchy), 在该目录树下存储所有文件和目录.

目录层次结构从`根目录(root directory)`开始(在基于 UNIX 的系统中, 根目录就记为“/”), 并使用某种`分隔符(separator)`来命名后续`子目录(sub-directories)`, 直到`命名所需的文件或目录`. 

例如, 如果用户在根目录中创建了一个目录 foo, 然后在目录 foo中创建了一个文件 bar.txt, 我们就可以通过它的绝对路径名(absolute pathname)来引用该文件, 在这个例子中, 它将是/foo/bar.txt. 更复杂的目录树, 请参见图 39.1. 示例中的`有效目录是/, /foo, /bar, /bar/bar, /bar/foo`, 有效的`文件是/foo/bar.txt 和/bar/foo/bar.txt`. 目录和文件可以具有相同的名称, 只要它们位于文件系统树的不同位置(例如, 图中有两个名为bar.txt的文件: /foo/bar.txt 和/bar/foo/bar.txt). 

![](assets/Pasted%20image%2020230410172625.png)

> 提示：请仔细考虑命名

`命名`是计算机系统的一个重要方面.在 UNIX 系统中,你几乎可以想到的所有内容都是通过文件系统命名的.除了文件、设备、管道,甚至进程可以在一个看似普通的旧文件系统中看到.这种命名的一致性简化了系统的概念模型,使系统更简单、更模块化.因此,无论何时创建系统或接口,都要仔细考虑你使用的是什么名称.

你可能还会注意到,这个例子中的文件名通常包含两部分：bar 和 txt,以句点分隔.第一部分是任意名称,而文件名的第二部分通常用于`指示文件的类型(type)`, 例如, 它是 C代码(例如.c)还是图像(例如.jpg),或音乐文件(例如.mp3).然而,这通常只是一个惯例(convention)：一般不会强制名为 main.c 的文件中包含的数据确实是 C 源代码.

因此,我们可以看到文件系统提供的了不起的东西：一种方便的方式来`命名`我们感兴趣的所有文件.`名称`在系统中很重要,因为访问任何资源的第一步是能够命名它.在 UNIX系统中,文件系统提供了一种统一的方式来访问磁盘, U 盘, CD-ROM, 许多其他设备上的文件, 事实上还有很多其他的东西, 都位于单一目录树下. 

## 39.2 文件系统接口

现在让我们更详细地讨论文件系统接口. 我们将从`创建, 访问和删除文件`的基础开始. 
你可能会认为这很简单, 但在这个过程中, 你会发现用于`删除文件`的神秘调用, `称为unlink()`. 
希望阅读本章之后,你不再困惑！

## 39.3 创建文件

我们将从最基本的操作开始: 创建一个文件. 这可以通过 `open 系统调用`完成. 通过调用 open()并传入 `O_CREAT 标志`, 程序可以`创建一个新文件`. 下面是示例代码, 用于在当前工作目录中创建名为“foo”的文件. 
```c
int fd = open("foo", O_CREAT | O_WRONLY | O_TRUNC);
```

函数open()接受一些不同的标志. 在本例中, 程序创建文件(O_CREAT), 只能写入该文件, 因为以(O_WRONLY)这种方式打开, 并且如果该文件已经存在, 则首先将其截断为零字节大小, `删除所有现有内容(O_TRUNC)`. 

> 补充：creat()系统调用

`int fd = creat("foo");` 你可以认为creat()是 open()加上以下标志: O_CREAT | O_WRONLY | O_TRUNC.  因为 open()可以创建一个文件, 所以 creat()的用法有些失宠(实际上, 它可能就是实现为对 open()的一个库调用). 

open()的一个重要方面是它的`返回值`: `文件描述符(file descriptor)`.文件描述符只是一个`整数`,是`每个进程私有的`, 在UNIX系统中用于访问文件. 因此, 一旦文件被打开, 你就可以使用文件描述符来读取或写入文件, 假定你有权这样做. 这样, 一个文件描述符就是一种`权限(capability)`, 即一个不透明的句柄, 它可以让你执行某些操作.另一种看待文件描述符的方法,是将它作为指向文件类型对象的`指针`.一旦你有这样的对象,就可以调用其他“方法”来访问文件,如 read()和 write().下面你会看到如何使用文件描述符.

## 39.4 读写文件

一旦我们有了一些文件,当然就会想要读取或写入.我们先读取一个现有的文件.如果在命令行键入,我们就可以用 cat 程序,将文件的内容显示到屏幕上.

```shell
prompt> echo hello > foo
prompt> cat foo
hello
prompt>
```
在这段代码中,我们将程序 echo 的输出重定向到文件 foo, 然后文件中就包含单词“hello”.然后我们用 cat 来查看文件的内容.但是, cat 程序如何访问文件 foo？

为了弄清楚这个问题,我们将使用一个非常有用的工具,来`跟踪程序所做的系统调用`.在 Linux 上,该工具称为 `strace`.其他系统也有类似的工具(参见 macOS X 上的 dtruss,或某些较早的 UNIX 变体上的 truss). strace 的作用就是`跟踪程序在运行时所做的每个系统调用`,然后将跟踪结果显示在屏幕上供你查看.

> 提示：使用 strace(和类似工具)

strace 工具提供了一种非常棒的方式,来查看程序在做什么.通过运行它,你可以跟踪程序生成的系统调用,查看参数和返回代码,通常可以很好地了解正在发生的事情.
该工具还接受一些非常有用的参数.例如,-f 跟踪所有 fork 的子进程,-t 报告每次调用的时间,-e trace=open,close,read,write `只跟踪对这些系统调用的调用`,并`忽略所有其他调用`.还有许多更强大的标志,请阅读手册页,弄清楚如何利用这个奇妙的工具.

下面是一个例子,使用 strace 来找出 cat 在做什么(为了可读性删除了一些调用).
```shell
prompt> strace cat foo
...
open("foo", O_RDONLY|O_LARGEFILE) = 3
read(3, "hello\n", 4096)          = 6
write(1, "hello\n", 6)            = 6
hello
read(3, "", 4096)                 = 0
close(3)                          = 0
...
prompt>
```

cat 做的第一件事是`打开文件`准备读取. 
我们应该注意几件事情. 首先, 该文件仅为读取而打开(不写入), 如 O_RDONLY 标志所示. 其次, 使用 64 位偏移量(O_LARGEFILE). 最后, open()调用成功并返回一个文件描述符, 其值为 3. 

你可能会想, 为什么第一次调用 open()会返回 3, 而不是 0 或 1？事实证明, `每个正在运行的进程已经打开了 3 个文件`：`标准输入`(进程可以读取以接收输入), `标准输出`(进程可以写入以便将信息显示到屏幕), 以及`标准错误`(进程可以写入错误消息). 这些分别由文件描述符 0, 1 和 2 表示. 因此, 当你第一次打开另一个文件时(如上例所示), 它几乎肯定是文件描述符 3.

打开成功后，`cat 使用 read()系统调用`重复读取文件中的一些字节。read()的`第一个参数`是文件描述符，从而告诉文件系统读取哪个文件。一个进程当然可以同时打开多个文件，因此描述符使操作系统能够知道某个特定的读取引用了哪个文件。`第二个参数`指向一个用于放置 read()结果的缓冲区。在上面的系统调用跟踪中，strace 显示了这时的读取结果（“hello”）。`第三个参数`是缓冲区的大小，在这个例子中是 4KB。对 read()的调用也成功返回，这里`返回它读取的字节数`（6，其中包括“hello”中的 5 个字母和一个行尾标记）。

此时，你会看到 strace 的另一个有趣结果：对 `write()系统调用`的一次调用，针对文件描述符 1。如上所述，此描述符被称为`标准输出`，因此用于将单词“Hello”写到屏幕上，这正是 cat 程序要做的事。但是它直接调用 write()吗？也许（如果它是高度优化的）。但是，如果不是，那么可能会调用`库例程 printf()`。
在内部，printf()会计算出传递给它的所有格式化细节，并最终对标准输出调用 write，将结果显示到屏幕上。

然后，cat 程序试图从文件中读取更多内容，但由于文件中没有剩余字节，read()返回 0，程序知道这意味着它已经读取了整个文件。因此，程序调用 close()，传入相应的文件描述符，表明它已用完文件“foo”。该文件因此被关闭，对它的读取完成了. 

写入文件是通过一组类似的步骤完成的。首先，打开一个文件准备写入，然后调用 write()系统调用，对于较大的文件，可能重复调用，然后调用 close()。使用 strace 追踪写入文件，或许针对你自己编写的程序，或者`追踪 dd 实用程序`，例如 dd if = foo of = bar。

## 39.5 读取和写入，但不按顺序

到目前为止, 我们已经讨论了如何读取和写入文件, 但`所有访问`都是`顺序的(sequential)`. 也就是说, 我们从头到尾读取一个文件, 或者从头到尾写一个文件. 

然而, 我们有时能够读取或写入`文件中的特定偏移量`.  

例如，如果你在文本文件上构建了索引并利用它来查找特定单词，最终可能会从文件中的某些随机(random)偏移量中读取数据. 为此，我们将使用 `lseek()系统调用`。下面是函数原型：
```c
off_t lseek(int fildes, off_t offset, int whence);
```

第一个参数是熟悉的(一个文件描述符). 第二个参数是偏移量, 它将文件偏移量定位到文件中的特定位置. 第三个参数, 由于历史原因而被称为 whence, 明确地指定了`搜索的执行方式`. 以下摘自手册页：
```shell
If whence is SEEK_SET, the offset is set to offset bytes.
If whence is SEEK_CUR, the offset is set to its current location plus offset bytes.
If whence is SEEK_END, the offset is set to the size of the file plus offset bytes.
```

从这段描述中可见，对于`每个进程打开的文件`, `操作系统都会跟踪一个“当前”偏移量`, 这将决定在文件中读取或写入时, 下一次读取或写入`开始的位置`. 因此, `打开文件的抽象包括它具有当前偏移量`, 偏移量的更新有两种方式. 
第一种是当发生N个字节的读或写时, N被添加到`当前偏移.` 因此, 每次读取或写入都会隐式更新偏移量. 第二种是`明确的lseek`, 它改变了上面指定的偏移量. 

> 补充：调用 lseek()不会执行磁盘寻道

命名糟糕的系统调用 lseek()让人困惑, 试图去理解`磁盘`以及其上的`文件系统`如何工作. 不要混淆! 
lseek()调用只是在 `OS内存中`更改一个`变量`, 该变量`跟踪`特定进程的下一个读取或写入开始的`偏移量`.

如果发送到磁盘的读取或写入与最后一次读取或写入不在同一磁道上，就会发生磁盘寻道，因此需要磁头移动。
调用 lseek()从文件的随机位置读取或写入文件，然后读取/写入这些随机位置，确实会导致更多的磁盘寻道。因此，调用 lseek()肯定会导致在即将进行的读取或写入中进行搜索，但绝对不会导致任何磁盘 I/O 自动发生. 

请注意, 调用 lseek()与移动磁盘臂的磁盘的寻道(seek)操作无关. 对 lseek()的调用只是`改变内核中变量的值`. 执行 I/O 时, 根据磁盘头的位置, 磁盘可能会也可能不会执行实际的寻道来完成请求. 

## 39.6 用 fsync()立即写入

大多数情况下，当程序调用 write()时，它只是告诉文件系统：请在将来的某个时刻，将此数据写入持久存储。出于`性能的原因`，文件系统会将这些写入在`内存中缓冲(buffer)`一段时间(例如 5s 或 30s). 在稍后的时间点, 写入将实际发送到存储设备. 

从调用应用程序的角度来看，写入似乎很快完成，并且只有在极少数情况下（例如，在 write()调用之后但写入磁盘之前，机器崩溃）数据会丢失。

但是，有些应用程序需要的不只是这种保证。例如，在数据库管理系统（DBMS）中，开发正确的恢复协议要求能够经常强制写入磁盘。

为了支持这些类型的应用程序, 大多数文件系统都提供了一些额外的控制 API. 在 UNIX中, 提供给应用程序的接口被称为 `fsync(int fd)`. 当进程针对特定文件描述符`调用 fsync()`时, 文件系统通过`强制将所有脏(dirty)数据(即尚未写入的)写入磁盘`来响应, 针对指定文件描述符引用的文件. 一旦所有这些写入完成, fsync()例程就会返回. 

以下是如何使用 fsync()的简单示例。代码打开文件 foo，向它写入一个数据块，然后调用 fsync()以确保`立即强制写入磁盘`。一旦 fsync()返回，应用程序就可以`安全地继续前进`，知道数据已被保存（如果 fsync()实现正确，那就是了）。
```c
int fd = open("foo", O_CREAT | O_WRONLY | O_TRUNC);
assert(fd > -1);
int rc = write(fd, buffer, size);
assert(rc == size);
rc = fsync(fd);
assert(rc == 0);
```

这段代码`并不能保证`你所期望的一切。在某些情况下，还需要 `fsync()`包含`foo文件的目录`。添加此步骤不仅可以确保文件本身位于磁盘上, 而且可以`确保文件(如果新创建)也是目录的一部分`。毫不奇怪，这种细节往往被忽略，导致许多应用程序级别的错误.

## 39.7 文件重命名

有了一个文件后，有时需要给一个文件一个不同的名字。在命令行键入时，这是通过mv 命令完成的。在下面的例子中，文件 foo 被重命名为 bar。
```shell
prompt> mv foo bar
```

利用 strace，我们可以看到 mv 使用了系统调用 `rename(char * old, char * new)`，它只需要两个参数：文件的原来名称(old)和新名称(new). 

`rename()调用`提供了一个有趣的保证: 它(通常)是一个`原子(atomic)调用`, 不论系统是否崩溃. 如果系统在重命名期间崩溃, 文件将被命名为旧名称或新名称, 不会出现中间状态. 因此, 对于支持某些需要对文件状态进行原子更新的应用程序, rename()非常重要. 

让我们更具体一点. 想象一下, 你正在使用`文件编辑器`(例如emacs), 并`将一行插入到文件的中间`. 例如, 该文件的名称是foo.txt. 编辑器更新文件并确保新文件包含原有内容和插入行的方式如下(为简单起见, 忽略错误检查)：
```c
int fd = open("foo.txt.tmp", O_WRONLY|O_CREAT|O_TRUNC);
write(fd, buffer, size); // write out new version of file
fsync(fd);
close(fd);
rename("foo.txt.tmp", "foo.txt");
```

在这个例子中, 编辑器做的事很简单: 将文件的新版本写入`临时`名称(foot.txt.tmp), 使用fsync()将其强制写入磁盘. 然后, 当应用程序确定新文件的元数据和内容在磁盘上, 就将`临时文件`重命名为原有文件的名称. 最后一步自动将新文件交换到位, 同时删除旧版本的文件, 从而实现原子文件更新.

## 39.8 获取文件信息

除了文件访问之外, 我们还希望文件系统能够保存关于它正在存储的每个`文件的`大量`信息`. 我们通常将这些数据称为`文件元数据(metadata)`. 要`查看特定文件的元数据`, 我们可以使用`stat()或fstat()系统调用`. 这些调用`将一个路径名(或文件描述符)添加到一个文件中`, 并`填充一个stat结构`, 如下所示: 
```c
struct stat {
	dev_t st_dev; /* ID of device containing file */
	ino_t st_ino; /* inode number */
	mode_t st_mode; /* protection */
	nlink_t st_nlink; /* number of hard links */
	uid_t st_uid; /* user ID of owner */
	gid_t st_gid; /* group ID of owner */
	dev_t st_rdev; /* device ID (if special file) */
	off_t st_size; /* total size, in bytes */
	blksize_t st_blksize; /* blocksize for filesystem I/O */
	blkcnt_t st_blocks; /* number of blocks allocated */
	time_t st_atime; /* time of last access */
	time_t st_mtime; /* time of last modification */
	time_t st_ctime; /* time of last status change */
};
```

你可以看到有关于每个文件的大量信息, 包括其大小(以字节为单位), 其低级名称(即inode号), 一些所有权信息以及有关何时文件被访问或修改的一些信息, 等等. 要查看此信息, 可以使用命令行工具 stat：
```shell
prompt> echo hello > file
prompt> stat file
File: 'file'
Size: 6 Blocks: 8 IO Block: 4096 regular file
Device: 811h/2065d Inode: 67158084 Links: 1
Access: (0640/-rw-r-----) Uid: (30686/ remzi) Gid: (30686/ remzi)
Access: 2011-05-03 15:50:20.157594748 -0500
Modify: 2011-05-03 15:50:20.157594748 -0500
Change: 2011-05-03 15:50:20.157594748 -0500
```

事实表明, 每个文件系统通常将这种类型的信息`保存在一个名为inode的结构`中. 当我们讨论文件系统的实现时, 会学习更多关于inode的知识. 就目前而言, 你应该`将inode看作是由文件系统保存的持久数据结构`, 包含上述信息. 

## 39.9 删除文件

现在, 我们知道了如何创建文件并按顺序访问它们. 但是, 如何删除文件？如果用过UNIX, 你可能认为你知道：只需运行程序 rm. 但是, rm 使用什么系统调用来删除文件？我们再次使用老朋友 strace 来找出答案. 下面删除那个讨厌的文件“foo”：
```shell
prompt> strace rm foo
...
unlink("foo")           = 0
...
```

我们从跟踪的输出中删除了一堆不相关的内容, 只留下一个神秘名称的`系统调用unlink()`. 如你所见, unlink()只需要待删除文件的名称, 并在`成功时返回零`. 但这引出了一个很大的疑问: 为什么这个系统调用名为“unlink”？为什么不就是“remove”或“delete”？要理解这个问题的答案, 我们不仅要先了解文件, 还有`目录`. 

## 39.10 创建目录

除了文件外, 还可以使用一组`与目录相关的系统调用`来创建, 读取和删除目录. 

注意, `不能直接写入目录`. 因为`目录的格式`被视为`文件系统元数据`, 所以你只能`间接更新目录`, 例如, 通过在其中创建文件, 目录或其他对象类型. 通过这种方式, 文件系统可以确保目录的内容始终符合预期. 

要创建目录，可以用系统调用 mkdir()。同名的 mkdir 程序可以用来创建这样一个目录。让我们看一下，当我们运行 mkdir 程序来创建一个名为 foo 的简单目录时，会发生什么：
```shell
prompt> strace mkdir foo
...
mkdir("foo", 0777)        = 0
...
prompt>
```

>提示：小心强大的命令
>程序rm为我们提供了强大命令的一个好例子, 也说明有时太多的权利可能是一件坏事. 

这样的目录创建时, 它被认为是“空的”, 尽管它`实际上包含最少的内容`. 具体来说, `空目录有两个条目: 一个引用自身的条目. 一个引用其父目录的条目`. 前者称为“.”(点)目录，后者称为“..”(点-点)目录. 你可以通过向程序 ls 传递一个标志(-a)来查看这些目录: 
```shell
prompt> ls -a
./ ../
prompt> ls -al
total 8
drwxr-x--- 2 remzi remzi 6 Apr 30 16:17 ./
drwxr-x--- 26 remzi remzi 4096 Apr 30 16:17 ../
```

## 39.11 读取目录

既然我们创建了目录, 也可能希望读取目录. 实际上, 这正是 ls 程序做的事. 让我们编写像 ls 这样的小工具, 看看它是如何做的. 

不是像打开文件一样打开一个目录, 而是使用一组新的调用. 下面是一个打印目录内容的示例程序. 该程序使用了 opendir(), readdir()和 closedir()这 3 个调用来完成工作, 你可以看到接口有多简单. 我们只需使用一个简单的循环就可以一次读取一个目录条目, 并打印目录中每个文件的名称和 inode 编号. 

```c
int main(int argc, char *argv[]) {
	DIR *dp = opendir(".");
	assert(dp != NULL);
	struct dirent *d;
	while ((d = readdir(dp)) != NULL) {
		printf("%d %s\n", (int) d->d_ino, d->d_name);
	}
	closedir(dp);
	return 0;
}
```

下面的声明在struct dirent数据结构中, 展示了每个目录条目中可用的信息.
```c
struct dirent {
	char d_name[256]; /* filename */
	ino_t d_ino; /* inode number */
	off_t d_off; /* offset to the next dirent */
	unsigned short d_reclen; /* length of this record */
	unsigned char d_type; /* type of file */
};
```

由于目录只有少量的信息(基本上, 只是将名称映射到inode号, 以及少量其他细节), 程序可能需要在每个文件上调用stat()以获取每个文件的更多信息, 例如其长度或其他详细信息. 实际上, 这正是 ls 带有`-l标志`时所做的事情。请试着对带有和不带有`-l标志`的ls运行strace, 自己看看结果.

## 39.12 删除目录

最后, 你可以通过`调用rmdir()`来删除目录(它由相同名称的程序 rmdir使用). 然而, 与删除文件不同, 删除目录更加危险, 因为你可以使用单个命令删除大量数据. 因此,` rmdir()要求该目录在被删除之前是空的`(只有“.”和“..”条目). 如果你`试图删除一个非空目录`, 那么对`rmdir()的调用就会失败`. 

## 39.13 硬链接

我们现在回到`为什么删除文件是通过unlink()`的问题, 理解`在文件系统树中创建条目`的新方法, 即通过所谓的`link()系统调用`. link()系统调用有两个参数: 一个旧路径名和一个新路径名. 当你将一个新的文件名“链接”到一个旧的文件名时, 你实际上创建了另一种引用同一个文件的方法. `命令行程序ln`用于执行此操作, 如下面的例子所示:

```shell
prompt> echo hello > file
prompt> cat file
hello
prompt> ln file file2
prompt> cat file2
hello
```

在这里, 我们创建了一个文件, 其中包含单词“hello”, 并称之为file. 然后, 我们用ln程序创建了该文件的一个`硬链接`. 在此之后, 我们可以通过打开file或file2来检查文件. 

link 只是在要创建链接的目录中创建了另一个名称，并将其`指向原有文件的相同inode号`, 该文件不以任何方式复制. 相反, 你现在就有了两个人类可读的名称(file和file2), 都指向同一个文件. 通过打印每个文件的inode号, 我们甚至可以在目录中看到这一点：

```shell
prompt> ls -i file file2
67158084 file
67158084 file2
prompt>
```

通过带`-i `标志的 ls，它会打印出每个文件的 inode 编号(以及文件名). 因此, 你可以看到实际上已完成的链接: 只是对同一个inode号(本例中为 67158084)创建了新的引用. 

现在, 你可能已经开始明白unlink()名称的由来. `创建一个文件时, 实际上做了两件事.` 

首先, 要`构建一个结构(inode)`, 它将`跟踪几乎所有关于文件的信息`, 包括其大小, 文件块在磁盘上的位置等等. 其次, 将人类`可读的名称链接到该文件`, 并`将该链接放入目录中`. 

在创建文件的硬链接之后, 在文件系统中, 原有文件名(file)和新创建的文件名(file2)之间没有区别。实际上, 它们都`只是指向文件底层元数据的链接`, 可以在inode编号67158084中找到.

因此, 为了从文件系统中删除一个文件, 我们调用 unlink(). 在上面的例子中, 我们可以删除文件名 file，并且仍然毫无困难地访问该文件：
```shell
prompt> rm file
removed 'file'
prompt> cat file2
hello
```

这样的结果是因为`当文件系统取消链接文件`时, 它`检查inode号中`的`引用计数(reference count)`. 该引用计数(有时称为`链接计数`, link count)允许文件系统`跟踪有多少不同的文件名`已链接到这个inode. 调用unlink()时, 会`删除人类可读的名称`(正在删除的文件)与`给定inode号之间`的`“链接”`, 并`减少引用计数`. 只有当`引用计数达到零`时, 文件系统才会`释放inode和相关数据块`, 从而`真正“删除”该文件`. 

当然, 你可以使用 stat()来查看文件的引用计数. 让我们看看创建和删除文件的硬链接时, 引用计数是什么. 在这个例子中，我们将为同一个文件创建 3 个链接，然后删除它们。仔细看链接计数！
```shell
prompt> echo hello > file
prompt> stat file
... Inode: 67158084 Links: 1 ...
prompt> ln file file2
prompt> stat file
... Inode: 67158084 Links: 2 ...
prompt> stat file2
... Inode: 67158084 Links: 2 ...
prompt> ln file2 file3
prompt> stat file
... Inode: 67158084 Links: 3 ...
prompt> rm file
prompt> stat file2
... Inode: 67158084 Links: 2 ...
prompt> rm file2
prompt> stat file3
... Inode: 67158084 Links: 1 ...
prompt> rm file3
```

## 39.14 符号链接

还有一种非常有用的链接类型, 称为符号链接(symbolic link), 有时称为软链接(soft link). 事实表明, 硬链接有点局限: 你`不能创建目录的硬链接`(因为担心会在目录树中创建一个环).  你不能硬链接到`其他磁盘分区中的文件`(因为inode号在特定文件系统中是唯一的, 而不是跨文件系统), 等等. 因此, 人们创建了一种称为符号链接的新型链接. 

要创建这样的链接, 可以使用相同的程序 l, 但使用`-s `标志。下面是一个例子. 
```shell
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
```
如你所见, 创建软链接看起来几乎相同, 现在可以通过文件名称 file 以及符号链接名称file2 来访问原始文件. 

但是, 除了表面相似之外, 符号链接实际上与硬链接`完全不同`. 

第一个区别是`符号链接`本身实际上`是一个不同类型的文件`. 我们已经讨论过常规文件和目录. 符号链接是`文件系统知道的第三种类型`. 对符号链接运行 stat 揭示了一切.

```shell
prompt> stat file
... regular file ...
prompt> stat file2
... symbolic link ...
```

运行 ls 也揭示了这个事实. 如果仔细观察ls输出的长格式的第一个字符, 可以看到`常规文件`最左列中的第一个字符`是“-”`, 目录是“d”, `软链接是“l”`. 你还可以看到符号链接的大小(本例中为4个字节), 以及链接指向的内容(名为 file 的文件).

```shell
prompt> ls -al
drwxr-x--- 2 remzi remzi 29 May 3 19:10 ./
drwxr-x--- 27 remzi remzi 4096 May 3 15:14 ../
-rw-r----- 1 remzi remzi 6 May 3 19:10 file
lrwxrwxrwx 1 remzi remzi 4 May 3 19:10 file2 -> file
```

file2是4个字节, 原因在于形成符号链接的方式, 即`将链接指向文件的路径名`作为`链接文件的数据`. 因为我们`链接到一个名为file的文件`, 所以我们的链接文件file2很小(4个字节). 如果链接到更长的路径名, 链接文件会更大. 

```shell
prompt> echo hello > alongerfilename
prompt> ln -s alongerfilename file3
prompt> ls -al alongerfilename file3
-rw-r----- 1 remzi remzi 6 May 3 19:17 alongerfilename
lrwxrwxrwx 1 remzi remzi 15 May 3 19:17 file3 -> alongerfilename
```

最后，由于创建符号链接的方式，有可能造成所谓的悬空引用(dangling reference). 
```shell
prompt> echo hello > file
prompt> ln -s file file2
prompt> cat file2
hello
prompt> rm file
prompt> cat file2
cat: file2: No such file or directory
```

正如你在本例中看到的, 符号链接与硬链接完全不同, 删除名为file的原始文件会导致符号链接指向不再存在的路径名.

# Ch40 文件系统实现


本章将介绍一个简单的文件系统实现, 称为VSFS(Very Simple File System, 简单文件系统). 它是典型 UNIX 文件系统的简化版本, 因此可用于介绍一些基本磁盘结构, 访问方法和各种策略, 你可以在当今许多文件系统中看到. 

文件系统是纯软件. 与CPU和内存虚拟化的开发不同, 我们不会添加硬件功能来使文件系统的某些方面更好地工作(但我们需要注意设备特性, 以确保文件系统运行良好). 由于在构建文件系统方面具有很大的灵活性, 因此人们构建了许多不同的文件系统, 从AFS(Andrew文件系统)到ZFS(Sun的 Zettabyte文件系统). 所有这些文件系统都有不同的数据结构, 在某些方面优于或逊于同类系统. 因此, 我们学习文件系统的方式是通过案例研究: 首先, 通过本章中的简单文件系统(VSFS)介绍大多数概念. 然后, 对真实文件系统进行一系列研究, 以了解它们在实践中有何区别. 

关键问题：如何实现简单的文件系统
如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？

## 40.1 思考方式

考虑文件系统时，我们通常建议考虑它们的两个不同方面。如果你理解了这两个方面，可能就理解了文件系统基本工作原理。

第一个方面是`文件系统的数据结构(data structure)`。换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？我们即将看到的第一个文件系统(包括下面的VSFS)使用简单的结构, 如块或其他对象的数组, 而更复杂的文件系统(如 SGI 的 XFS)使用更复杂的基于树的结构.

第二个方面是`访问方法(access method)`. 如何将进程发出的调用, 如 open(), read(), write()等, 映射到它的结构上? 在执行特定系统调用期间读取哪些结构? 改写哪些结构? 所有这些步骤的执行效率如何? 

如果你理解了文件系统的数据结构和访问方法，就形成了一个关于它如何工作的良好心智模型，这是系统思维的一个关键部分。在深入研究我们的第一个实现时，请尝试建立你的心智模型。

> 补充：文件系统的心智模型

心智模型就是你在学习系统时真正想要发展的东西。对于文件系统，你的心智模型最终应该包含以下问题的答案：磁盘上的哪些结构存储文件系统的数据和元数据？当一个进程打开一个文件时会发生什么？在读取或写入期间访问哪些磁盘结构？通过研究和改进心智模型，你可以对发生的事情有一个抽象的理解，而不是试图理解某些文件系统代码的细节.

## 40.2 整体组织

我们现在来开发VSFS文件系统在磁盘上的数据结构的整体组织. 我们需要做的第一件事是`将磁盘分成块(block)`. 简单的文件系统只使用一种块大小, 这里正是这样做的. 我们选择常用的 4KB。

因此, 我们把构建文件系统的`磁盘分区`看成 `一系列块`, 每块大小为4KB. 在大小为N个4KB块的分区中, 这些块的地址为从0到N-1. 假设我们有一个非常小的磁盘, 只有64块:

![](assets/Pasted%20image%2020230410213237.png)

现在让我们考虑一下, 为了构建文件系统, 需要在这些块中存储什么. 当然, 首先想到的是`用户数据`. 实际上, 任何文件系统中的大多数空间都是(并且应该是)用户数据. 我们将`用于存放用户数据的磁盘区域`称为`数据区域(data region)`, 简单起见, 将磁盘的固定部分留给这些块, 例如磁盘上64个块的最后 56 个: 

![](assets/Pasted%20image%2020230410213410.png)

文件系统必须记录每个文件的信息. 该信息是元数据(metadata)的关键部分, 并且记录诸如文件包含哪些数据块(在数据区域中), 文件的大小, 其所有者和访问权限, 访问和修改时间以及其他类似信息的事情. 为了存储这些信息, 文件系统通常有一个名为`inode的结构`.

为了存放inode, 我们还需要在磁盘上留出一些空间. 我们将`这部分磁盘称为inode表(inode table)`, 它只是保存了一个磁盘上inode的数组. 因此, 假设我们将64个块中的5块用于inode, 磁盘映像现在看起来如下:

![](assets/Pasted%20image%2020230410213941.png)

在这里应该指出, `inode通常不是那么大`, 例如, 只有128或256字节. 假设每个inode有256字节, 一个 4KB 块可以容纳16个inode, 而我们上面的文件系统则包含80个inode. 在我们简单的文件系统中, 建立在一个小小的64块分区上, 这个数字表示文件系统中可以拥有的最大文件数量. 但是请注意, 建立在更大磁盘上的相同文件系统可以简单地分配更大的inode表, 从而容纳更多文件. 

到目前为止, 我们的文件系统有了`数据块(D)`和`inode(I)`, 但还缺一些东西. 你可能已经猜到, 还需要某种方法来`记录inode或数据块是空闲还是已分配`. 因此, 这种`分配结构(allocation structure)是所有文件系统中必需`的部分.

当然, 可能有许多分配记录方法. 
例如, 我们可以用一个空闲列表(free list), 指向第一个空闲块, 然后它又指向下一个空闲块, 依此类推. 
我们选择一种简单而流行的结构, 称为`位图(bitmap)`, 一种用于`数据区域`(数据位图, data bitmap), 另一种用于`inode表`(inode位图，inode bitmap).  

位图是一种简单的结构: `每个位`用于指示相应的对象/块是`空闲(0)`还是`正在使用(1)`. 因此新的磁盘布局如下, 包含`inode位图(i)`和`数据位图(d)`: 

![](assets/Pasted%20image%2020230410214917.png)

你可能会注意到, 对这些位图使用整个4KB块是有点杀鸡用牛刀. 这样的位图可以记录32KB对象是否分配, 但我们只有80个inode和56个数据块. 但是, 简单起见, 我们就为每个位图使用整个4KB块. 

在我们的极简文件系统的磁盘结构设计中, 还有一块. 我们将它保留给`超级块(superblock)`, 在下图中用 S 表示. 

`超级块`包含关于该`特定文件系统`(如ext2等)的信息, 包括例如文件系统中有多少个inode和数据块(在这个例子中分别为80和56), inode表的开始位置(块 3)等等. 它可能还包括一些magic数, 来标识文件系统类型(在本例中为VSFS).  超级快是文件系统的核心部分.

![](assets/Pasted%20image%2020230410215436.png)

因此, 在`挂载文件系统时`, OS将`首先读取超级块`, 初始化各种参数, 然后`将该卷添加到文件系统树`中. 当卷中的文件被访问时, 系统就会知道在哪里查找所需的磁盘上的结构. 

## 40.3 文件组织: inode

文件系统最重要的磁盘结构之一是inode, 几乎所有的文件系统都有类似的结构. 名称inode是index node(索引节点)的缩写, 它是由UNIX开发人员Ken Thompson给出的历史性名称, 因为这些节点最初放在一个`数组`中, 在访问特定inode时会用到`该数组的索引`. 

> 补充: 数据结构——inode

inode是许多文件系统中使用的通用名称, 用于描述保存给定文件的元数据的结构, 例如其长度, 权限以及其组成块的位置. 它是index node(索引节点)的缩写, 因为inode号用于索引磁盘上的inode 数组, 以便查找该inode号对应的inode. 

每个inode都`由一个数字(称为 inumber)`隐式引用, 我们之前称之为文件的底层名称(low-level name). 在VSFS(和其他简单的文件系统)中, 给定一个inumber, 你应该能够直接计算磁盘上相应节点的位置. 

例如, 如上所述, 获取VSFS的inode表: 大小为20KB(5 个4KB块), 因此由80个inode(假设每个 inode为256字节)组成. 进一步假设`inode区域`从 12KB 开始(即超级块从 0KB 开始, inode 位图在 4KB 地址, 数据位图在 8KB, 因此 inode 表紧随其后). 因此, 在 VSFS 中, 我们为文件系统分区的开头提供了以下布局(特写视图): 

![](assets/Pasted%20image%2020230410220626.png)

要读取 inode 号 32, 文件系统首先会计算 inode 区域的偏移量(32×size(inode), 即8192), 将它加上磁盘 inode 表的起始地址(inodeStartAddr = 12KB), 从而得到希望的 inode块的正确字节地址: 20KB. 回想一下, 磁盘不是按字节可寻址的, 而是由大量`可寻址扇区`组成, 通常是512字节. 因此, 为了获取包含索引节点 32 的索引节点块, 文件系统将向节点(即 40)发出一个读取请求, 取得期望的 inode 块. 更一般地说, inode 块的扇区地址 iaddr可以计算如下：

```c
blk = (inumber * sizeof(inode_t)) / blockSize;
sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;
```

在每个 inode 中, 实际上是所有关于文件的信息: 文件类型(例如，常规文件、目录等), 大小, 分配给它的块数, 保护信息(如谁拥有该文件以及谁可以访问它), 一些时间信息(包括文件创建, 修改或上次访问的时间文件下), 以及有关其`数据块`驻留在磁盘上的位置的信息(如某种类型的指针). 我们将所有关于文件的信息称为`元数据(metadata)`. 实际上, 文件系统中除了纯粹的用户数据外, 其他任何信息通常都称为元数据. 表 40.1 所示的是 ext2的 inode 的例子.

![](assets/Pasted%20image%2020230410222431.png)

设计 inode 时, 最重要的决定之一是它`如何引用数据块的位置`. 一种简单的方法是在inode中有一个或多个`直接指针(磁盘地址)`. 每个指针指向属于该文件的一个磁盘块. 这种方法有局限: 例如, 如果你想要一个非常大的文件(例如, 大于块的大小乘以直接指针数), 那就不走运了.

### 多级索引

为了支持更大的文件, 文件系统设计者必须在 inode 中引入不同的结构. 

一个常见的思路是有一个称为`间接指针(indirect pointer)`的特殊指针. 它不是指向包含用户数据的块, 而是`指向包含更多指针的块`, 每个指针指向用户数据. 

因此, inode可以有一些`固定数量(例如 12 个)的直接指针`和一个间接指针. 如果文件变得足够大, 则会分配一个间接块(来自磁盘的数据块区域), 并将inode的间接指针设置为指向它. 假设一个块是 4KB, 磁盘地址是4字节, 那就增加了1024个指针. 文件可以增长到(12+1024)×4KB, 即4144KB. 

在这种方法中，你可能希望支持更大的文件。为此，只需添加另一个指向inode 的指针：双重间接指针（double indirect pointer）。该指针指的是一个包含间接块指针的块，每个间接块都包含指向数据块的指针。因此，双重间接块提供了可能性，允许使用额外的 1024×1024 个 4KB 块来增长文件，换言之，支持超过 4GB 大小的文件。不过，你可能想要更多，我们打赌你知道怎么办：三重间接指针（triple indirect pointer）。

总之，这种不平衡树被称为指向文件块的多级索引（multi-level index）方法。

许多文件系统使用多级索引, 包括常用的文件系统, 如Linux ext2和ext3, NetApp的 WAFL, 以及原始的UNIX文件系统. 其他文件系统, 包括SGI XFS和Linux ext4, 使用范围而不是简单的指针.

为什么使用这样的不平衡树？为什么不采用不同的方法？
因为 大多数文件很小. 

> 提示：考虑基于范围的方法
>另一种方法是使用范围（extent）而不是指针。范围就是一个磁盘指针加一个长度（以块为单位）。因此，不需要指向文件的每个块的指针，只需要指针和长度来指定文件的磁盘位置。只有一个范围是有局限的，因为分配文件时可能无法找到连续的磁盘可用空间块。因此，基于范围的文件系统通常允许多个范围，从而在文件分配期间给予文件系统更多的自由。
>
>这两种方法相比较，基于指针的方法是最灵活的，但是每个文件使用大量元数据（尤其是大文件）。基于范围的方法不够灵活但更紧凑。特别是，如果磁盘上有足够的可用空间并且文件可以连续布局（无论如何，这实际上是所有文件分配策略的目标），基于范围的方法都能正常工作。

![](assets/Pasted%20image%2020230410223705.png)

## 40.4 目录组织

在VSFS中(像许多文件系统一样), 目录的组织很简单. 一个`目录`基本上`只包含一个二元组(条目名称, inode号)`的列表. 对于给定目录中的每个文件或目录, `目录的数据块`中都有`一个字符串和一个数字`. 对于每个字符串, 可能还有一个长度(假定采用可变大小的名称). 

例如, 假设目录dir(inode 号是 5)中有 3 个文件(foo、bar 和 foobar), 它们的 inode号分别为 12, 13 和 24. dir 在磁盘上的数据可能如下所示:

![](assets/Pasted%20image%2020230410224347.png)

在这个例子中, 每个条目都有一个 inode 号, 记录长度(名称的总字节数加上所有的剩余空间), 字符串长度(名称的实际长度), 最后是条目的名称. 
请注意. `每个目录有两个额外的条目: .(点)和..(点点)`. 点目录就是当前目录(在本例中为 dir), 而点点是父目录(在本例中是根目录). 

`删除一个文件`(例如调用 unlink())会在`目录中间留下一段空白空间`, 因此应该有一些方法来标记它(例如, 用一个`保留的 inode 号`, 比如 0). 这种删除是使用记录长度的一个原因：新条目可能会重复使用旧的, 更大的条目, 从而在其中留有额外的空间. 

你可能想知道`确切的目录存储在哪里`. 

通常, 文件系统将`目录视为特殊类型的文件`. 因此, 目录有一个inode, 位于 inode 表中的某处(inode 表中的 inode 标记为“目录”的类型字段, 而不是“常规文件”). 该目录具有由 inode 指向的数据块(也可能是间接块). 这些数据块存在于我们的简单文件系统的数据块区域中. 我们的磁盘结构因此保持不变. 

这个简单的线性目录列表并不是存储这些信息的唯一方法. 任何数据结构都是可能的. 例如, XFS 以 B 树形式存储目录, 使文件创建操作(必须确保文件名在创建之前未被使用)快于使用简单列表的系统, 因为后者必须扫描其中的条目.

## 40.5 空闲空间管理

文件系统必须记录哪些 inode 和数据块是`空闲的`, 哪些不是, 这样在分配新文件或目录时, 就可以为它找到空间. 因此, `空闲空间管理(free space management)`对于所有文件系统都很重要. 在VSFS 中, 我们用两个简单的位图来完成这个任务. 

例如, 当我们创建一个文件时, 我们必须为该文件分配一个 inode. 文件系统将通过位图搜索一个空闲的内容, 并将其分配给该文件. 文件系统必须将 inode 标记为`已使用(用 1)`, 并最终用正确的信息更新磁盘上的位图. 分配数据块时会发生类似的一组活动. 

为新文件分配数据块时，还可能会考虑其他一些注意事项。
例如, 一些 Linux 文件系统(如 ext2 和 ext3)在创建新文件并需要数据块时, 会寻找`一系列空闲块`(如 8 块). 通过找到这样一系列空闲块, 然后将它们分配给新创建的文件, 文件系统保证文件的一部分将在磁盘上并且是连续的, 从而提高性能. 因此, 这种`预分配(pre-allocation)策略`, 是为数据块分配空间时的常用启发式方法. 

补充：空闲空间管理
管理空闲空间可以有很多方法, 位图只是其中一种. 一些早期的文件系统使用空闲列表(free list),其中超级块中的单个指针保持指向第一个空闲块. 在该块内部保留下一个空闲指针, 从而通过系统的空闲块形成列表. 在需要块时, 使用头块并相应地更新列表. 

现代文件系统使用更复杂的数据结构. 例如, SGI的XFS使用某种形式的B树(B-tree)来紧凑地表示磁盘的哪些块是空闲的. 与所有数据结构一样, 不同的时间-空间折中也是可能的. 

## 40.6 访问路径：读取和写入

现在我们已经知道文件和目录如何存储在磁盘上，我们应该能够明白读取或写入文件的操作过程。理解这个`访问路径(access path)`上发生的事情, 是开发人员理解文件系统如何工作的第二个关键。请注意！

对于下面的例子, 我们假设`文件系统已经挂载`, 因此`超级块已经在内存`中. 其他所有内容(如 inode、目录)仍在磁盘上. 

### 从磁盘读取文件

在这个简单的例子中, 让我们先假设你只是想打开一个文件(例如/foo/bar, 读取它, 然后关闭它). 对于这个简单的例子, 假设文件的大小只有 4KB(即1块).

当你发出一个`open("/foo/bar", O_RDONLY)调用`时, `文件系统`首先需要`找到文件bar的inode`, 从而`获`取关于该`文件的一些基本信息`(权限信息、文件大小等等). 为此, 文件系统必须能够找到 inode, 但它现在只有完整的路径名. `文件系统必须遍历(traverse)路径名`, 从而找到所需的 inode. 

`所有遍历`都`从文件系统的根开始`, 即`根目录(root directory)`，它就记为`/`. 

因此. 文件系统的`第一次磁盘读取`是`根目录的inode`. 但是这个 inode 在哪里? 
要找到inode, 我们必须`知道它的i-number`. 通常, 我们在`其父目录中`找到`文件或目录的i-number`. 根没有父目录(根据定义). 因此, 根的inode号必须是“众所周知的”. 在挂载文件系统时, 文件系统必须知道它是什么. 在大多数 UNIX 文件系统中, `根的inode号为 2`. 因此, 要开始该过程, 文件系统会读入 inode 号2的块(第一个 inode 块). 

> 文件系统第一次读取的是inumber为2的 根目录的inode.

一旦 inode 被读入, 文件系统可以在其中`查找指向数据块的指针`, `数据块包含根目录的内容`. 因此, 文件系统将使用这些磁盘上的指针来`读取目录`, 在这个例子中, 寻找 foo 的条目. 通过读入一个或多个`目录数据块`, 它将找到 foo 的条目. 一旦找到, 文件系统也会找到下一个需要的 foo 的 inode 号(假定是 44). 

> 找到根目录的inode, 就通过指针去数据块找到 目录条目, 然后找到foo的条目. 找到了foo的条目, foo的inode号 inumber也就找到了.

下一步是`递归遍历路径名`, 直到找到所需的 inode. 在这个例子中, 文件系统读取包含`foo的inode`及其`目录数据的块`, 最后`找到bar的inode号`. `open()的最后一步是将bar的inode读入内存`. 然后`文件系统进行最后的权限检查`, 在每个进程的打开文件表中, 为此进程分配一个文件描述符, 并将它返回给用户. 

> 找到foo的inode号, 就可以找到foo目录下有啥了, 找到了bar 条目, 得到bar的inode. open()最后一步把bar的inode读入内存, 进行权限检查. 然后在每个进程的打开文件表里, 为此进程分配一个文件描述符, 然后把文件描述符返回给用户. (因为拿到inode 就可以计算出该文件所在的扇区了)

打开后, 程序可以发出read()系统调用, 从文件中读取. 第一次读取(除非lseek()已被调用, 则在偏移量0处)将在文件的第一个块中读取, 查阅inode以查找这个块的位置. 它也会用新的最后访问时间更新 inode. 读取将进一步更新此文件描述符在内存中的打开文件表, 更新文件偏移量, 以便下一次读取会读取第二个文件块, 等等. 

补充：读取不会访问分配结构

我们曾见过许多学生对分配结构（如位图）感到困惑。特别是，许多人经常认为，只是简单地读取文件而不分配任何新块时，也会查询位图。不是这样的！分配结构（如位图）只有在需要分配时才会访问。inode、目录和间接块具有完成读请求所需的所有信息。inode 已经指向一个块，不需要再次确认它已分配。

在某个时候，文件将被关闭。这里要做的工作要少得多。很明显，文件描述符应该被释放，但现在，这就是 FS 真正要做的。没有磁盘 I/O 发生。

整个过程如表 40.3 所示（向下时间递增）。在该表中，打开导致了多次读取，以便最终找到文件的 inode。之后，读取每个块需要文件系统首先查询 inode，然后读取该块，再使用写入更新 inode 的最后访问时间字段。花一些时间，试着理解发生了什么。

![](assets/Pasted%20image%2020230410233448.png)

另外请注意，open 导致的 I/O 量与路径名的长度成正比. 对于路径中的每个增加的目录, 我们都必须读取它的 inode 及其数据. 更糟糕的是, 会出现大型目录. 在这里, 我们只需要读取一个块来获取目录的内容, 而对于大型目录, 我们可能需要读取很多数据块才能找到所需的条目. 是的, 读取文件时生活会变得非常糟糕. 你会发现, 写入一个文件（尤其是创建一个新文件）更糟糕. 

### 写入磁盘

写入文件是一个类似的过程. 首先, 文件必须打开(如上所述). 其次, 应用程序可以发出 write()调用以用新内容更新文件. 最后, 关闭该文件. 

与读取不同, `写入文件`也`可能会分配(allocate)一个块`(除非块被覆写). 当`写入一个新文件`时, `每次写入操作`不仅需要将数据写入磁盘, 还必须`首先决定将哪个块分配给文件`, 从而相应地`更新磁盘的其他结构`(例如数据位图和 inode). 

因此, `每次写入文件`在逻辑上会导致`5个I/O`: 一个读取`数据位图`(然后更新以标记新分配的块被使用), 一个`写入位图`(将它的新状态存入磁盘), 再是`两次读取`, 然后`写入 inode`(用新块的位置更新), 最后一次`写入真正的数据块`本身。

考虑简单和常见的操作(例如文件创建), 写入的工作量更大. 要创建一个文件, 文件系统不仅要分配一个 inode, 还要在`包含新文件的目录`中`分配空间`. 这样做的 I/O 工作总量非常大: 一个读取 inode 位图(查找空闲 inode), 一个写入 inode 位图(将其标记为已分配), 一个写入新的 inode 本身(初始化它), 一个写入目录的数据(将文件的高级名称链接到它的 inode 号), 以及一个读写目录 inode 以便更新它. 如果目录需要增长以容纳新条目, 则还需要额外的 I/O(即数据位图和新目录块). 所有这些只是为了创建一个文件!

我们来看一个具体的例子，其中创建了file `/foo/bar`，并且向它写入了 3 个块。表 40.4展示了在 open()（创建文件）期间和在 3 个 4KB 写入期间发生的情况。

![](assets/Pasted%20image%2020230410234327.png)

在该表中, 对磁盘的读取和写入放在导致它们发生的系统调用之下, 它们可能发生的大致顺序从表的顶部到底部依次进行. 你可以看到创建该文件需要多少工作: 在这种情况下, 有 10 次 I/O, 用于遍历路径名, 然后创建文件. 你还可以看到每个分配写入需要 5 次I/O：一对读取和更新 inode，另一对读取和更新数据位图，最后写入数据本身. 

文件系统如何以合理的效率完成这些任务？

关键问题：如何降低文件系统 I/O 成本
即使是最简单的操作，如打开、读取或写入文件，也会产生大量 I/O 操作，分散在磁盘上。文件系统可以做些什么，来降低执行如此多 I/O 的高成本？

## 40.7 缓存和缓冲

如上面的例子所示，读取和写入文件可能是昂贵的，会导致(慢速)磁盘的许多 I/O. 这显然是一个巨大的性能问题，为了弥补，大多数文件系统积极使用`系统内存(DRAM)`来`缓存重要的块`. 

想象一下上面的打开示例：没有缓存，每个打开的文件都需要对目录层次结构中的每个级别至少进行两次读取（一次读取相关目录的 inode，并且至少有一次读取其数据）。使用长路径名（例如，/1/2/3/…/100/file.txt），文件系统只是为了打开文件，就要执行数百次读取！

早期的文件系统因此引入了一个固定大小的缓存（fixed-size cache）来保存常用的块。正如我们在讨论虚拟内存时一样，`LRU 及不同变体策略`会决定哪些块保留在缓存中。这个固定大小的缓存通常会`在启动时分配`，大约占总内存的 10%。

然而，这种`静态的内存划分`（static partitioning）可能导致浪费。如果文件系统在给定的时间点不需要 10%的内存，该怎么办？使用上述固定大小的方法，文件高速缓存中的未使用页面不能被重新用于其他一些用途，因此导致浪费。

相比之下，现代系统采用`动态划分`（dynamic partitioning）方法。具体来说，许多现代操作系统将`虚拟内存页`和`文件系统页`集成到`统一页缓存`中(unified page cache)。
通过这种方式，可以在虚拟内存和文件系统之间更灵活地分配内存，具体取决于在给定时间哪种内存需要更多的内存。

现在想象一下有缓存的文件打开的例子。第一次打开可能会产生很多 I/O 流量，来读取目录的 inode 和数据，但是随后文件打开的同一文件（或同一目录中的文件），大部分会命中缓存，因此不需要 I/O。

我们也考虑一下`缓存对写入的影响`。尽管可以通过足够大的缓存完全避免读取 I/O，但写入流量必须进入磁盘，才能实现持久。因此，`高速缓存不能减少写入流量`，像对读取那样。虽然这么说，写缓冲（write buffering，人们有时这么说）肯定有许多优点。首先，通过延迟写入，文件系统可以将一些更新`编成一批（batch）`，放入一组较小的 I/O 中.

例如，如果在创建一个文件时，inode 位图被更新，稍后在创建另一个文件时又被更新，则文件系统会`在第一次更新后延迟写入`，从而`节省一次 I/O`。其次，通过将一些写入缓冲在内存中，系统可以调度（schedule）后续的 I/O，从而提高性能。最后，`一些写入可以通过拖延来完全避免`。例如，如果应用程序创建文件并将其删除，则将文件创建延迟写入磁盘，可以完全避免（avoid）写入。在这种情况下，懒惰（在将块写入磁盘时）是一种美德。

> 提示：理解静态划分与动态划分

在不同客户端/用户之间划分资源时，可以使用静态划分（static partitioning）或动态划分（dynamic partitioning）。

静态方法简单地将资源一次分成固定的比例。例如，如果有两个可能的内存用户，则可以给一个用户固定的内存部分，其余的则分配给另一个用户。

动态方法更灵活，随着时间的推移提供不同数量的资源。例如，一个用户可能会在一段时间内获得更高的磁盘带宽百分比，但是之后，系统可能会切换，决定为不同的用户提供更大比例的可用磁盘带宽。

每种方法都有其优点。静态划分可确保每个用户共享一些资源，通常提供更可预测的性能，也更易于实现。动态划分可以实现更好的利用率（通过让资源匮乏的用户占用其他空闲资源），但实现起来可能会更复杂，并且可能导致空闲资源被其他用户占用，然后在需要时花费很长时间收回，从而导致这些用户性能很差。像通常一样，没有最好的方法。你应该考虑手头的问题，并确定哪种方法最适合。实际上，你不是应该一直这样做吗？

由于上述原因，大多数现代文件系统将`写入在内存中缓冲 5～30s`，这代表了另一种折中：如果系统在更新传递到磁盘之前崩溃，更新就会丢失。但是，将内存写入时间延长，则可以通过批处理、调度甚至避免写入，提高性能。

某些应用程序（如数据库）不喜欢这种折中。因此，为了避免由于写入缓冲导致的意外数据丢失，它们就强制写入磁盘，通过`调用 fsync()`，使用`绕过缓存`的`直接 I/O（direct I/O）接口`，或者使用`原始磁盘（raw disk）接口`并完全避免使用文件系统。虽然大多数应用程序能接受文件系统的折中，但是如果默认设置不能令人满意，那么有足够的控制可以让系统按照你的要求进行操作.

> 提示：了解耐用性/性能权衡

存储系统通常会向用户提供耐用性/性能折中。如果用户希望写入的数据立即持久，则系统必须尽
全力将新写入的数据提交到磁盘，因此写入速度很慢（但是安全）。但是，如果用户可以容忍丢失少量数据，系统可以缓冲内存中的写入一段时间，然后将其写入磁盘（在后台）。这样做可以使写入快速完成，从而提高感受到的性能。但是，如果发生崩溃，尚未提交到磁盘的写入操作将丢失，因此需要进行折中。要理解如何正确地进行这种折中，最好了解使用存储系统的应用程序需要什么。例如，虽然丢失网络浏览器下载的最后几张图像可以忍受，但丢失部分数据库交易、让你的银行账户不能增加资金，这不能忍。当然，除非你很有钱。如果你很有钱，为什么要特别关心积攒每一分钱？

## 40.8 小结

我们已经看到了构建文件系统所需的基本机制。需要有关于每个文件（元数据）的一些信息，这通常存储在名为 inode 的结构中。目录只是“存储名称→inode 号”映射的特定类型的文件。其他结构也是需要的。例如，文件系统通常使用诸如位图的结构，来记录哪些 inode 或数据块是空闲的或已分配的。

文件系统设计的极好方面是它的自由。接下来的章节中探讨的文件系统，都利用了这种自由来优化文件系统的某些方面。显然，我们还有很多尚未探讨的策略决定。例如，创建一个新文件时，它应该放在磁盘上的什么位置？这一策略和其他策略会成为未来章节的主题吗？

# Ch41 局部性和快速文件系统

当UNIX操作系统首次引入时, Ken Thompson编写了第一个文件系统。我们称之为“老 UNIX 文件系统”，它非常简单，基本上，它的数据结构在磁盘上看起来像这样：

![](assets/Pasted%20image%2020230411175514.png)

超级块（S）包含有关整个文件系统的信息: 卷的大小, 有多少inode, 指向空闲列表块的头部的指针等等. 磁盘的 inode 区域包含文件系统的所有 inode。最后, 大部分磁盘都被数据块占用。

老文件系统的好处在于它很简单，支持文件系统试图提供的基本抽象：文件和目录层次结构。与早期系统提供的更简单的单层次层次结构相比，目录层次结构是真正的进步。

## 41.1 问题：性能不佳

上面那种性能不好哎. 主要问题是老 UNIX 文件系统将磁盘当成`随机存取内存`。数据遍布各处，而不考虑保存数据的介质是磁盘的事实，因此开销很大, 性能很低.  例如，文件的数据块通常离其 inode 非常远，因此每当第一次读取 inode 然后读取文件的数据块(非常常见的操作)时, 就会导致费时的寻道.

更糟糕的是，文件系统最终会变得非常`碎片化(fragmented),` 因为空闲空间没有得到精心管理。空闲列表最终会指向遍布磁盘的一堆块，并且随着文件的分配，它们只会占用下一个空闲块。结果是在磁盘上来回访问逻辑上连续的文件，从而大大降低了性能。

> 时间空间性能都很差. 但是已经有了, 再优化即可.

例如，假设以下数据块区域包含 4 个文件（A、B、C 和 D），每个文件大小为两个块：
![](assets/Pasted%20image%2020230411180121.png)

如果删除 B 和 D，则生成的布局为：
![](assets/Pasted%20image%2020230411180136.png)

如你所见，可用空间被分成两块构成的两大块，而不是很好的连续 4 块。假设我们现在希望分配一个大小为 4 块的文件 E：
![](assets/Pasted%20image%2020230411180213.png)

你可以看到会发生什么：E 分散在磁盘上，因此，在访问 E 时，无法从磁盘获得峰值（顺序）性能。你首先读取 E1 和 E2，然后寻道，再读取 E3 和 E4。这个碎片问题一直发生在老UNIX 文件系统中，并且会影响性能.  (这个问题正是磁盘碎片整理工具要解决的。它们将重新组织磁盘数据以连续放置文件，并为让空闲空间成为一个或几个连续的区域，移动数据，然后重写 inode 等以反映变化。)

另一个问题：`原始块大小太小`(512 字节). 因此, 从磁盘传输数据本质上是低效的. 
较小的块没问题, 因为它们最大限度地减少了内部碎片(internal fragmentation, 块内的浪费), 但是由于每个块可能需要一个定位开销来访问它，因此传输不佳。我们可以总结如下问题。

关键问题：如何组织磁盘数据以提高性能
如何组织文件系统数据结构以提高性能？在这些数据结构之上，需要哪些类型的分配策略？如何让文件系统具有“磁盘意识”？

## 41.2 FFS: 磁盘意识是解决方案

伯克利的一个小组决定建立一个更好, 更快的文件系统, 他们聪明地称之为快速文件系统(Fast File System, FFS). 
思路是让文件系统的结构和分配策略具有“磁盘意识”，从而提高性能.

通过保持与文件系统相同的接口(相同的API, 包括open(), read(), write(), close()和其他文件系统调用), 但改变内部实现, 作者为新文件系统的构建铺平了道路, 这方面的工作今天仍在继续. 
事实上，所有现代文件系统都遵循现有的接口(从而保持与应用程序的兼容性), 同时为了性能, 可靠性或其他原因, 改变其内部实现。

## 41.3 组织结构: 柱面组

第一步是`更改磁盘上的结构`。FFS 将磁盘划分为一些`分组`，称为`柱面组`(cylinder group).   
单个柱面是一个硬盘的不同盘面上的一组磁道, 它们与驱动器中心的距离相同; 它之所以被称为柱面, 是因为它与所谓的几何形状有着明显的相似性.  FFS 将N个连续的柱面聚集成一组, 因此整个硬盘可以看作是柱面组的集合. 
看个例子, 有六个盘片, 4个磁道. 一个柱面组由三个柱面组成.

![](assets/Pasted%20image%2020230411182123.png)

最里面的磁道组成的柱面不算在内. 所以是三个柱面组成一个组. (但这种分组法不用!)

注意, 现代驱动器不能导出足够的信息, 使文件系统无法真正理解某个特定的柱面是否正在使用; 如前所述, 磁盘导出块的逻辑地址空间, 并向用户隐藏其几何形状的细节.

所以, 现代文件系统(如linux ext2, ext3, 和ext4) 把磁盘组织成`块组(block group)`, 每个块组都是
硬盘地址空间的连续部分. 下图就表示了一个例子, 每8个块被组织成一个不同的块组.(注意 实际上的组包含更多的块).
![](assets/Pasted%20image%2020230411183200.png)

这些`分组是 FFS 用于改善性能的核心机制`。通过在同一组中放置两个文件，FFS 可以确保先后访问两个文件不会导致穿越磁盘的长时间寻道。

为了能使用这些组来存储文件和目录, FFS需要有能力把文件和目录放置在一个组里, 并且在其中跟踪它们的所有必要信息. 为了做到这点, FFS把所有你能想到的一个文件系统该有的所有结构都包含到每个组里了. 比如inodes的空间, 数据块, 和一些用来跟踪它们是否分配或空闲的数据结构.
每个组看起来像这样：

![](assets/Pasted%20image%2020230411183905.png)

我们现在描述一个柱面组的构成。出于可靠性原因，每个组中都有超级块(super block)的一个副本（例如，如果一个被损坏或划伤，你仍然可以通过使用其中一个副本来挂载和访问文件系统）。超级块是挂载文件系统用的.

在每个组中, 我们需要记录该组的 inode 和数据块是否已分配. 每组的 inode 位图(inode bitmap, ib)和数据位图(data bitmap, db)起到了这个作用, 分别针对每组中的inode和数据块. 位图是管理文件系统中可用空间的绝佳方法，因为很容易找到大块可用空间并将其分配给文件, 这可能会避免旧文件系统中空闲列表的某些碎片问题. 

最后，inode 和数据块区域就像之前的极简文件系统一样。像往常一样，每个柱面组的大部分都包含数据块。

## 41.4 策略：如何分配文件和目录

有了这个分组结构，FFS 现在必须决定，如何在磁盘上放置文件和目录以及相关的元数据，以提高性能。很简单：相关的东西放一起（以此推论，无关的东西分开放）。

因此，为了遵守规则，FFS 必须决定什么是“相关的”，并将它们置于同一个区块组内。相反，不相关的东西应该放在不同的块组中。为实现这一目标，FFS 使用了一些简单的放置推断方法。

首先是目录的放置。FFS 采用了一种简单的方法：找到分配数量少的柱面组（因为我们希望跨组平衡目录）和大量的自由 inode（因为我们希望随后能够分配一堆文件），并将目录数据和 inode 放在该分组中。当然，这里可以使用其他推断方法（例如，考虑空闲数据块的数量）。

对于文件，FFS 做两件事。首先，它确保（在一般情况下）将文件的数据块分配到与其inode 相同的组中，从而防止 inode 和数据之间的长时间寻道（如在老文件系统中）。其次，它将位于同一目录中的所有文件，放在它们所在目录的柱面组中。因此，如果用户创建了 4个文件，/dir1/1.txt、/dir1/2.txt、/dir1/3.txt 和/dir99/4.txt，FFS 会尝试将前 3 个放在一起（同一组），与第四个远离（它在另外某个组中）。

应该注意的是，这些推断方法并非基于对文件系统流量的广泛研究，或任何特别细致的研究。相反，它们建立在良好的老式常识基础之上（这不就是 CS 代表的吗？）。目录中的文件通常一起访问（想象编译一堆文件然后将它们链接到单个可执行文件中）。因为它们确保了相关文件之间的寻道时间很短，FFS 通常会提高性能。


PS: 后面的内容实际上用的不多. 以后再说. 包括第四部分, 分布式. NFS和AFS两个分布式文件系统.