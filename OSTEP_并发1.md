# Ch26 并发: 介绍

操作系统本身是第一个并发程序.
目前为止，我们已经看到了操作系统提供的基本抽象的发展.
看到了如何将一个物理CPU变成多个虚拟 CPU(virtual CPU). 从而支持多个程序同时运行的假象；还看到了如何为每个进程创建巨大的. 私有的虚拟内存(virtual memory)的假象, 这种地址空间(address space)的抽象让每个程序好像拥有自己的内存, 而实际上操作系统秘密地让多个地址空间复用物理内存(或者磁盘).

本章将介绍为`单个运行进程`提供的新抽象: 线程(thread).
与经典观点的一个程序单点执行(一个程序计数器，用来存放要执行的指令)不同, 多线程(multi-threaded)程序会有多个执行点(多个程序计数器, 每个都用于取指令和执行). 换一个角度来看, 每个线程类似于独立的进程, 只有一点区别: 它们共享同一个地址空间, 从而能够访问相同的数据.

因此一个单线程的状态跟进程的状态非常接近. 线程有一个程序计数器（PC），记录程序
从哪里获取指令。每个线程有自己私人的一组用于计算的寄存器. 因此 如果在一个单核处理器上运行两个线程, 那从一个线程(T1)切换到另一个线程(T2), 就会发生上下文切换.
线程间的上下文切换, 跟进程间的上下文切换是非常相似的, 因为T1的寄存器状态必须保存下来, T2在运行之前, 它的寄存器状态先被恢复.
对进程而言, 我们把状态保存到进程控制块(PCB)中. 现在我们需要一个或多个线程控制块(TCBs)来保存一个进程中每个线程的状态(现场).
然而跟进程相比, 我们在进行线程间上下文切换时, 有个主要区别, 就是线程间切换的虚拟地址空间不变(换言之, 不必切换正在使用的页表.).

另一个进程与线程间的主要区别在于栈. 
在简单的传统进程地址空间模型(我们现在可以称之为单线程(single-threaded)的进程), 只有一个栈, 通常位于地址空间的底部.

![](assets/Pasted%20image%2020230404164519.png)

然而, 在一个多线程的进程中, 每个线程都独立运行, 当然可以调用各种例程来完成正在执
行的任何工作. 多线程就不是地址空间只有一个栈了, 而是每个线程都有自己的栈空间(当然还是在进程空间内).
假设我们有个多线程的进程, 其中有2个线程. 地址空间看起来就跟单线程不一样了.

上图, 可以看到多线程空间分布, 有两个栈在进程的地址空间. 因此, 任何在栈上的变量, 参数, 返回值和其他放在栈上的东西, 都将被放置在称为本地线程的存储空间, 也就是线程相关的栈.

以前，堆和栈可以互不影响地增长，直到空间耗尽。多个栈就没有这么简单了。所幸，通常栈不会很大(除了大量使用递归的程序).

以上介绍了, 进程跟线程的区别. 进程是OS为任务分配资源的基本单位, 而线程是CPU调度的基本单位. 线程不能独立于进程而存在, OS不会为线程单独分配资源, 线程寄生于进程内.

## 26.0 为啥要用线程

讨论线程的细节之前, 你可能在写多线程程序的时候有些疑问. 先解决个简单问题, 为什么要用线程.

主要是两个原因:
第一个原因是, 并行. 比如你有一个很大的数组要处理, 跟另一个很大的数组相加, 或者是这个数组里的元素进行自加1. 如果是在单处理器上运行, 那就是普通的执行下去就行了. 但如果是在多处理器的机器上运行, 那就有加速运算的潜力了. 因为让每个处理器处理一部分工作, 多个处理器肯定比一个处理器工作快. 相当于一个人的活几个人同时干. 这就是并行. 
在现代硬件上, 每个CPU一个线程执行程序, 是很正常且典型地让程序运行更快的方式.

第二个原因, 是因为I/O操作很慢, 用线程可以避免阻塞程序进程.
幻想一下, 你在写一个要执行不同种类的I/O操作的程序, 为了完成一个显式硬盘I/O或者甚至完成(隐式)页错误处理, 需要等着去发送或接收信息. 你的程序可能希望去做其他的工作, 包括利用CPU去完成计算, 或者发另一个I/O请求, 而不是干等着. 
使用多线程就可以避免被停顿. 因为当一个线程等待的时候(就是因为等待I/O操作而被阻塞), CPU调度算法就可以切到其他就绪的线程, 去做一些有用的事.
在单个程序内, 线程使I/O操作与其他活动重叠, 就像多程序处理跨程序一样; 因此, 许多现代基于服务器的应用程序(Web服务器、数据库管理系统等)在其实现中使用线程。

当然, 上面提到的另一种情况, 你也可以使用多进程, 而不是多线程. 然而, 多线程共享一个地址空间, 所以多线程之间共享数据就很容易, 因此构建这类程序的时候, 多线程是自然选择.
多进程对逻辑上独立的任务是更可靠的选择, 他们共享的内存数据结构很少.

## 26.1 实例: 线程创建

假设我们想运行一个程序，它创建两个线程，每个线程都做了一些独立的工作，在这例子中，打印“A”或“B”。代码如图 26.2 所示.
```c
1 #include <stdio.h>
2 #include <assert.h>
3 #include <pthread.h>
4
5 void *mythread(void *arg) {
6     printf("%s\n", (char *) arg);
7     return NULL;
8 }
9
10 int
11 main(int argc, char *argv[]) {
12     pthread_t p1, p2;
13     int rc;
14     printf("main: begin\n");
15     rc = pthread_create(&p1, NULL, mythread, "A"); assert(rc == 0);
16     rc = pthread_create(&p2, NULL, mythread, "B"); assert(rc == 0);
17     // join waits for the threads to finish
18     rc = pthread_join(p1, NULL); assert(rc == 0);
19     rc = pthread_join(p2, NULL); assert(rc == 0);
20     printf("main: end\n");
21     return 0;
22 }
```
图 26.2 简单线程创建代码

让我们来看看这个小程序的可能执行顺序。在表 26.1 中，向下方向表示时间增加，每个列显示不同的线程（主线程、线程 1 或线程 2）何时运行。
![](assets/Pasted%20image%2020230404184026.png)
但请注意，这种排序不是唯一可能的顺序。实际上，给定一系列指令，有很多可能的顺序，这取决于调度程序决定在给定时刻运行哪个线程。例如，创建一个线程后，它可能会立即运行，这将导致表 26.2 中的执行顺序。

![](assets/Pasted%20image%2020230404184115.png)

我们甚至可以在“A”之前看到“B”，即使先前创建了线程 1，如果调度程序决定先运行线程 2，没有理由认为先创建的线程先运行。表 26.3 展示了最终的执行顺序，线程 2 在线程 1 之前先展示它的结果。

![](assets/Pasted%20image%2020230404184600.png)

如你所见，线程创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可能在从创建者返回之前运行，但也许会晚得多。

从这个例子中也可以看到，线程让生活变得复杂：已经很难说出什么时候会运行了！
没有并发，计算机也很难理解。有了并发, 程序运行更加复杂了.

## 26.2 为什么更糟糕：共享数据

上面演示的简单线程示例非常有用，它展示了线程如何创建，根据调度程序的决定，它们如何以不同顺序运行。
但是，它没有展示线程在访问共享数据时如何相互作用。
设想一个简单的例子，其中两个线程希望更新全局共享变量。我们要研究的代码如图 26.3
所示。
```c
1 #include <stdio.h>
2 #include <pthread.h>
3 #include "mythreads.h"
4
5 static volatile int counter = 0;
6
7 //
8 // mythread()
9 //
10 // Simply adds 1 to counter repeatedly, in a loop
11 // No, this is not how you would add 10,000,000 to
12 // a counter, but it shows the problem nicely.
13 //
14 void *
15 mythread(void *arg)
16 {
17     printf("%s: begin\n", (char *) arg);
18     int i;
19     for (i = 0; i < 1e7; i++) {
20         counter = counter + 1;
21     }
22     printf("%s: done\n", (char *) arg);
23     return NULL;
24 }
25
26 //
27 // main()
28 //
29 // Just launches two threads (pthread_create)
30 // and then waits for them (pthread_join)
31 //
32 int
33 main(int argc, char *argv[])
34 {
35     pthread_t p1, p2;
36     printf("main: begin (counter = %d)\n", counter);
37     Pthread_create(&p1, NULL, mythread, "A");
38     Pthread_create(&p2, NULL, mythread, "B");
39
40 // join waits for the threads to finish
41     Pthread_join(p1, NULL);
42     Pthread_join(p2, NULL);
43     printf("main: done with both (counter = %d)\n", counter);
44     return 0;
45 }
```
图 26.3 共享数据

我们封装了线程创建和合并例程, 以便在失败时退出。Pthread_create()只需调用pthread_create()，并确保返回码为 0。如果不是，Pthread_create()就打印一条消息并退出。

其次，我们没有用两个独立的函数作为工作线程，只使用了一段代码，并向线程传入一个参数（在本例中是一个字符串），这样就可以让每个线程在打印它的消息之前，打印不同的字母。

最后，最重要的是，我们现在可以看看每个工作线程正在尝试做什么：向共享变量计数器添加一个数字，并在循环中执行 1000 万(10^7)次。因此，预期的最终结果是：2000 0000。

然而事实是, 每次运行不但会产生错误，而且得到不同的结果！有一个大问题：为什么会发生这种情况？

![](assets/Pasted%20image%2020230404203154.png)
![](assets/Pasted%20image%2020230404203203.png)

>反汇编程序(disassembler), 如objdump(Linux)来查看汇编代码.
>objdump 程序只是应该学习使用的许多工具之一。像 gdb 这样的调试器，像 valgrind或 purify 这样的内存分析器，当然编译器本身也应该花时间去了解更多信息。工具用得越好，就可以建立更好的系统。

## 26.3 核心问题：不可控的调度

为了理解为什么会发生这种情况, 我们必须了解编译器为更新计数器生成的代码序列.
在这个例子中，我们只是想给 counter 加上一个数字（1）。因此，做这件事的代码序列可能
看起来像这样(在 x86 中):
```asm
mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
```
这个例子假定，变量 counter 位于地址 0x8049a1c.
在这 3 条指令中，先用 x86 的 mov指令，从内存地址处取出值，放入 eax。然后，给 eax 寄存器的值加 1（0x1）。最后，eax的值被存回内存中相同的地址。

设想我们的两个线程之一(线程 1)进入这个代码区域, 并且因此将要增加一个计数器. 它将 counter 的值(假设它这时是 50)加载到它的寄存器 eax 中。因此, 线程1的eax = 50。然后它向寄存器加 1，因此 eax = 51。现在，一件不幸的事情发生了：时钟中断发生。因此，操作系统将当前正在运行的线程(它的程序计数器、寄存器，包括 eax 等)的状态保存到线程的TCB。

更糟的事发生了：线程 2 被选中运行，并进入同一段代码。它也执行了第一条指令，获取计数器的值并将其放入其 eax 中(运行时每个线程都有自己的专用寄存器。上下文切换代码将寄存器虚拟化(virtualized), 保存并恢复它们的值). 此时 counter 的值仍为 50，因此线程 2 的 eax = 50。假设线程 2 执行接下来的两条指令，将 eax 递增 1（因此 eax = 51），然后将 eax 的内容保存到 counter（地址 0x8049a1c）中。因此，全局变量 counter 现在的值是 51。

最后，又发生一次上下文切换，线程 1 恢复运行。还记得它已经执行过 mov 和 add 指
令，现在准备执行最后一条 mov 指令。回忆一下，eax=51。因此，最后的 mov 指令执行，
将值保存到内存，counter 再次被设置为 51.

总结一下, 就是本来counter应该被两个线程各加一次, 最终得到52. 但事实是, 线程1的寄存器中的结果还没写回内存, 就被时钟中断打断, 把CPU资源给了线程2.

为了更好地理解问题, 让我们追踪一下详细的执行. 假设在这个例子中, 上面的代码被加载到内存中的地址 100 上, 就像下面的序列一样(熟悉类似RISC指令集的人请注意: x86 具有可变长度指令. 这个mov指令占用5个字节的内存, add 只占用 3 个字节):
```c
100 mov 0x8049a1c, %eax
105 add $0x1, %eax
108 mov %eax, 0x8049a1c
```

有了这些假设，发生的情况如表 26.4 所示。假设 counter 从 50 开始，并追踪这个例子，确保你明白发生了什么。

![](assets/Pasted%20image%2020230404222853.png)

这里展示的情况称为竞态条件（race condition）：结果取决于代码的时间执行。
由于运气不好（即在执行过程中发生的上下文切换），我们得到了错误的结果。事实上，可能每次
都会得到不同的结果。因此，我们称这个结果是不确定的（indeterminate），而不是确定的
(deterministic)计算(我们习惯于从计算机中得到).
不确定的计算不知道输出的是什么，它在不同运行中确实可能是不同的。

由于执行这段代码的多个线程可能导致`竞争状态`，因此我们将此段代码称为`临界区`（critical section）。
`临界区`是`访问共享变量`（或更一般地说，共享资源）的`代码片段`，`一定不能由多个线程同时执行`。
(临界区绝对不能够并行修改).

我们真正想要的代码就是所谓的互斥（mutual exclusion）。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区。

(事实上，所有这些术语都是由 Edsger Dijkstra 创造的，他是该领域的先驱，并且因为这
项工作和其他工作而获得了图灵奖。)

## 26.4 原子性愿望

解决这个问题的一种途径是拥有更强大的指令，单步就能完成要做的事，从而消除不合时宜的中断的可能性。比如，如果有这样一条超级指令怎么样？
`memory-add 0x8049a1c, $0x1`
假设这条指令将一个值添加到内存位置，并且硬件保证它以`原子`方式（atomically）执行。
当指令执行时, 它会像期望那样执行更新变量在内存的值。它不能在指令中间被中断打断，因为这正是我们从硬件获得的保证：发生中断时，指令`要么还没有运行`, 要么就`运行完成`, 没有中间状态。

在这里，`原子`方式的意思是“作为一个整体单元”, 有时我们说“1或0”. 我们希望以原子方式执行 3 个指令的序列：
```
mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
```
如果有一条指令来做到上面的活, 我们可以发出这条指令然后完事. 
但在一般情况下，不会有这样的指令。设想我们要构建一个并发的 B 树，并希望更新它。我们真的希望硬件支持“B 树的原子性更新”指令吗？可能不会，至少理智的指令集不会。

因此，我们要做的是要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即所谓的`同步原语`(synchronization primitive).
通过使用这些硬件同步原语，加上操作系统的一些帮助，我们将能够构建多线程代码，以`同步和受控`的方式`访问临界区`，从而`可靠地产生正确的结果`—— 尽管有并发执行的挑战。

补充：关键并发术语
临界区、竞态条件、不确定性、互斥执行

临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。
竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。
不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果。
为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。

这是一个精彩而困难的问题.

关键问题：如何实现同步
为了构建有用的同步原语，需要从硬件中获得哪些支持？需要从操作系统中获得什么支持？如何正确有效地构建这些原语？程序如何使用它们来获得期望的结果？

## 26.5 还有一个问题: 等待另一个线程

本章提出了并发问题，就好像线程之间只有一种交互，即访问共享变量，因此需要为临界区支持原子性。
事实上，还有另一种常见的交互，即一个线程在继续之前必须等待另一个线程完成某些操作。
例如，当进程执行磁盘 I/O 并进入睡眠状态时，会产生这种交互。当 I/O 完成时，该进程需要从睡眠中唤醒，以便继续进行。

在接下来的章节中，我们不仅要研究如何构建对`同步原语的支持`来支持`原子性`，还要研究支持在多线程程序中常见的`睡眠/唤醒交互的机制`。

## 26.6 小结：为什么操作系统课要研究并发

为什么我们要在 OS 类中研究并发? 
因为操作系统就是第一个并发程序. 很多的技术被发明出来首先就是用在操作系统中的.
后来, 应用层程序员也必须考虑多线程的进程这些事.

例如, 设想有两个进程正在运行. 假设它们都调动write()写入文件, 且都希望把数据追加到文件中.(把数据添加到文件末尾). 为此, 两个进程都必须分配一个新块, 记录在该块所在文件的inode中, 并更改文件的大小以反映新的, 增加的大小. 因为中断可能随时发生, 所以更新这些共享结构的代码是临界区.
因此，从引入中断的一开始，OS 设计人员就不得不担心操作系统如何更新内部结构. 不合时宜的中断会导致上述所有问题。毫不奇怪，页表、进程列表、文件系统结构以及几乎每个内核数据结构都必须小心地访问，并使用正确的同步原语才能正常工作。

>提示：使用原子操作

原子操作是构建计算机系统的最强大的基础技术之一，从计算机体系结构到并行代码, 文件系统, 数据库管理系统, 甚至分布式系统.

将一系列动作原子化(atomic)背后的想法可以简单用一个短语表达: “全部或没有”. 看上去，要么你希望组合在一起的所有活动都发生了, 要么它们都没有发生. 不会看到中间状态.
有时，将许多行为组合为单个原子动作称为事务(transaction). 这是一个在数据库和事务处理世界中非常详细地发展的概念.

探讨并发的主题中, 我们将使用同步原语, 将指令的短序列变成原子性的执行块.
但是我们会看到, 原子性的想法远不止这些. 例如, 文件系统使用诸如日志记录或写入时复制等技术来自动转换其磁盘状态, 这对于在系统故障时正确运行至关重要.

# Ch27 插叙: 线程API

本章介绍了主要的线程 API。后续章节也会进一步介绍如何使用 API。
关键问题：如何创建和控制线程？
操作系统应该提供哪些创建和控制线程的接口？这些接口如何设计得易用和实用？

## 27.1 线程创建

编写多线程程序的第一步就是创建新线程，因此必须存在某种线程创建接口。在 POSIX中，很简单：

```c
#include <pthread.h>
int
pthread_create( pthread_t *            thread,
                const pthread_attr_t * attr,
                void * (*start_routine)(void*),
                void * arg);
```

该函数有 4 个参数：thread、attr、start_routine 和 arg。
第一个参数 thread 是指向 pthread_t 结构类型的指针,  我们将利用这个结构与该线程交互，因此需要将它传入pthread_create(), 以便将它初始化.

第二个参数 attr 用于指定该线程可能具有的任何属性. 比如: 设置栈大小, 或关于该线程调度优先级的信息. 一个属性通过单独调用 pthread_attr_init()来初始化. 详细信息，请参阅手册. 但是，在大多数情况下，默认值就行。在这个例子中，我们只需传入 NULL。

第三个参数最复杂，但它实际上只是问：这个线程应该在哪个函数中运行？这个参数是函数指针. 存放的是函数的入口地址. 返回值是`void *`类型. 函数参数是`void *`类型.

第四个参数 arg 就是要传递给线程开始执行的函数的参数. 第三个参数是函数指针, 这第四个参数, 就是函数指针的参数.

下面来看图 27.1 中的例子。这里我们只是创建了一个线程，传入两个参数，它们被打包成一个我们自己定义的类型（myarg_t）。该线程一旦创建，可以简单地将其参数转换为它所期望的类型，从而根据需要将参数解包。

```c
#include <assert.h>
#include <stdio.h>
#include <pthread.h>

typedef struct {
    int a;
    int b;
} myarg_t;

void *mythread(void *arg) {
    myarg_t *args = (myarg_t *) arg;
    printf("%d %d\n", args->a, args->b);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    myarg_t args = { 10, 20 };

    int rc = pthread_create(&p, NULL, mythread, &args);
    assert(rc == 0);
    (void) pthread_join(p, NULL);
    printf("done\n");
    return 0;
}
```
图 27.1 创建线程

一旦你创建了一个线程，你确实拥有了另一个活着的执行实体，它有自己的调用栈，与程序中所有当前存在的线程在相同的地址空间内运行。好玩的事开始了！

## 27.2 线程完成

如果你想等待线程完成, 你需要做一些特别的事情来等待完成。具体来说，你必须调用函数 pthread_join()。

该函数有两个参数。第一个是 pthread_t 类型，用于指定要等待的线程。这个变量是由线程创建函数初始化的（当你将一个指针作为参数传递给 pthread_create()时）。如果你保留了它，就可以用它来等待该线程终止.

第二个参数是一个指针, 指向你希望得到的返回值. 因为函数可以返回任何东西，所以它被定义为返回一个指向 void 的指针。因为 pthread_join()函数改变了传入参数的值，所以你需要传入一个指向该值的指针，而不只是该值本身。

我们来看另一个例子（见图 27.2）。

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include "common_threads.h"

typedef struct {
    int a;
    int b;
} myarg_t;

typedef struct {
    int x;
    int y;
} myret_t;

void *mythread(void *arg) {
    myarg_t *args = (myarg_t *) arg;
    printf("args %d %d\n", args->a, args->b);
    myret_t *rvals = malloc(sizeof(myret_t));
    assert(rvals != NULL);
    rvals->x = 1;
    rvals->y = 2;
    return (void *) rvals;
}

int main(int argc, char *argv[]) {
    pthread_t p;
    myret_t *rvals;
    myarg_t args = { 10, 20 };
    Pthread_create(&p, NULL, mythread, &args);
    Pthread_join(p, (void **) &rvals);
    printf("returned %d %d\n", rvals->x, rvals->y);
    free(rvals);
    return 0;
}
```
图 27.2 等待线程完成

在代码中，再次创建单个线程，并通过 myarg_t 结构传递一些参数。对于返回值，使用 myret_t 型接收。一旦线程运行完毕，等待在`pthread_join()`例程中的主线程就会返回，我们可以访问从线程返回的值，即 `myret_t` 中的值. 

有几点需要说明. 首先, 我们常常打包, 解包参数. 如果我们不需要参数, 创建线程时传入NULL即可. 类似的, 如果不需要返回值, 那么 `pthread_join()`调用也可以传入NULL.

其次，如果我们只传入一个值（例如，一个 int），也不必将它打包为一个参数。图 27.3 展示了一个例子。在这种情况下，更简单一些，因为我们不必在结构体中打包参数和返回值。
```c
void *mythread(void *arg) {
    long long int m = (long long int) arg;
    printf("%lld\n", m);
    return (void *) (m + 1);
}
int main(int argc, char *argv[]) {
    pthread_t p;
    long long int m;
    Pthread_create(&p, NULL, mythread, (void *) 100);
    Pthread_join(p, (void **) &m);
    printf("returned %d\n", m);
    return 0;
}
```
图 27.3 较简单的向线程传递参数示例

我们要十分当心线程返回值的方式. 永远不要返回一个指针, 这个指针指向在线程调用栈里分配的东西. 如果你这么做了, 你觉得会发生什么? 给你个危险的代码看看. 

```c
1  void *mythread(void *arg) {
2      myarg_t *args = (myarg_t *) arg;
3      printf("%d %d\n", args->a, args->b);
4      myret_t oops; // ALLOCATED ON STACK: BAD!
5      oops.x = 1;
6      oops.y = 2;
7      return (void *) &oops;
8  }
```

这个例子, 变量oops分配在mythread的栈上. 然而, 当函数运行完返回时, 这个变量已经被自动释放了. 所以, 传一个指向已经被释放的变量的指针出来, 会造成很多糟糕的结果.
当然, 当你打印那个你以为的返回值时, 你大概(但不一定)会吃惊.

最后，你可能会注注到，使用 pthread_create()创建线程，然后立即调用 pthread_join()，这是创建线程的一种非常奇怪的方式. 事实上，有一个更简单的方法来完成这个任务. 这个方法成为过程调用(procedure call). 
显然, 我们通常会创建不止一个线程, 并等它完成. 否则用线程就没多大意义了.

我们需要指出, 并非所有多线程的代码都适用join函数. 比如, 一个多线程web服务器可能会创建很多工作线程, 然后使用主线程接受请求，并将其无限期地传递给工作线程。因此这样的长期程序可能不需要 join. 然而, 创建线程来(并行)执行一个特定的并行任务，很可能就需要用join老确保在退出或进行下一阶段计算之前, 完成这些工作.

## 27.3 锁

除了线程创建和 join 之外, POSIX 线程库提供的最有用的函数集, 可能是通过锁（lock）来提供互斥进入临界区的那些函数.
实现这方面目的, 最基本的一对函数是：
`int pthread_mutex_lock(pthread_mutex_t *mutex);`
`int pthread_mutex_unlock(pthread_mutex_t *mutex);`
函数应该易于理解和使用。如果你注识到有一段代码是一个临界区，就需要通过锁来保护，以便像需要的那样正确运行。你大概可以想象代码的样子：
```c
pthread_mutex_t lock;
pthread_mutex_lock(&lock);
x = x + 1; // or whatever your critical section is
pthread_mutex_unlock(&lock);
```
这段代码的意思是：
如果在调用pthread_mutex_lock()时没有其他线程持有锁, 线程将获取该锁并进入临界区.
如果另一个线程已经持有该锁，那么尝试获取该锁的线程将不会从该调用返回，直到获得该锁（意味着持有该锁的线程通过unlock调用释放该锁）。
当然，在给定的时间内，许多线程可能会卡住，在获取锁的函数内部等待。然而只有持有锁的线程, 才应该调用unlock.

上面那段代码有两个重要的问题. 
第一个问题是, 没有正确的初始化(lack of proper initialization). 
所有的锁, 都必须正确初始化, 来保证他们开始时有正确的值. 并且在调用lock 和 unlock 的时候, 能够正常工作.

POSIX线程, 有两种方式初始化锁(initialize locks).
一种是利用 `PTHREAD_MUTEX_INITIALIZER` 这个常量宏直接赋值.
`pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;`
这么做给锁赋值为默认值, 让锁可用.

动态初始化(在运行时)的方法是, 调用`pthread_mutex_init()`:
```c
int rc = pthread_mutex_init(&lock, NULL);
assert(rc == 0); // always check success!
```

此函数的第一个参数是锁本身的地址，而第二个参数是一组可选属性。传入 NULL 就是使用默认值。我们通常使用动态（后者）方法.
注意，当你用完锁时，还应该相应地调用` pthread_mutex_destroy()`.

第二个问题是在调用获取锁和释放锁时没有检查错误代码. 
就像你在UNIX系统中调用的任何库一样, 这些函数也可能失败. 如果你的代码没有正确检查错误代码, 错误就会悄无声息的产生, 这会导致多个线程进入到临界区.
至少, 要用包装的函数, 给函数成功加上断言.(如图27.4)

```c
// Use this to keep your code clean but check for failures
// Only use if exiting program is OK upon failure
void Pthread_mutex_lock(pthread_mutex_t *mutex) {
    int rc = pthread_mutex_lock(mutex);
    assert(rc == 0);
}
```
图 27.4 包注函数示例

更复杂的(非玩具)程序, 在出现问题时不能简单地退出，应该检查失败并在获取锁或释放锁未成功时执行适当的操作。

lock和unlock函数, 并不是pthreads库中, 唯一与锁交互的函数.  还有两个你可能感兴趣的函数:
`int pthread_mutex_trylock(pthread_mutex_t *mutex);`
`int pthread_mutex_timedlock(pthread_mutex_t *mutex,struct timespec *abs_timeout);`

这俩函数用于获取锁. 如果锁已经被持有了, trylock函数就返回失败. timedlock函数会在超时, 或者获取锁之后(以先发生的为准), 返回. 
所以, 超时时长为0的timedlock函数, 就会退化成trylock函数. 通常应该避免这俩函数. 然而有些情况下, 需要避免卡在(可能会无限期)获取锁的函数里, 这俩函数还是有用的.(死锁的章节里会看到)

## 27.4 条件变量

任何线程库都有的另一个主要部分, 当然POSIX线程也在内, 就是条件变量(condition variable).
当线程间必须产生某种信号时, 如果一个线程在可以继续之前, 一直在等另一个线程执行某些操作, 那条件变量就派上用场了.
程序使用两个主要函数, 以期能如上交互:
```c
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_signal(pthread_cond_t *cond);
```

为了使用条件变量, 必须要有一把与此条件有关的锁. 当调用上面任何一个函数时, 这把锁应该是被持有的.

第一个函数pthread_cond_wait(), 让主调线程进入休眠状态, 因此等待其他某个线程给它发信号, 通常是 当程序里发生了某些 现在正在休眠的线程可能会关心的 变化.
典型用法如下:
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
Pthread_mutex_lock(&lock);
while (ready == 0)
    Pthread_cond_wait(&cond, &lock);
Pthread_mutex_unlock(&lock);
```

这段代码, 在初始化相关的锁和条件之后, 一个线程检查ready, 看变量ready是否已经被置为非0值.
如果ready依旧是0, 那就调用等待函数, 以休眠直到其他某个线程来唤醒它.

唤醒线程的代码运行在另外某个线程中，像下面这样：
```c
Pthread_mutex_lock(&lock);
ready = 1;
Pthread_cond_signal(&cond);
Pthread_mutex_unlock(&lock);
```

关于代码顺序有一些注意事项.
首先, 当发送信号时(还有当修改全局变量ready), 我们总要确保已经先持有锁. 这可以保证我们不会意外地引入竞态条件到我们的代码里.

其次, 你可能注意到了, wait调用 把某个锁(lock)作为它的第二个参数. 而signal调用只有一个条件参数. 造成这个区别的原因是 wait调用, 除了把主调线程休眠意外, 还会在让调用者进入休眠时, 释放锁.
想象一下, 如果不是这样, 那别的线程如何能够获取锁, 并给它发信号唤醒它. 然而, 在被唤醒之后, 在返回之前, pthread_cond_wait() 会重新获取锁, 从而确保`等待线程`运行 在等待序列开始时的锁获取和结束时的锁释放之间 , 这期间任何时刻, 它都持有锁。

最后一个注意点: 
等待线程在while循环里重复检查条件, 而不是简单的if语句. 后面学条件变量的时候再细聊. 但总体上用while简单且安全. 虽然它重新检查条件(可能增加点开销), 但有些pthread实现方式可能会错误地唤醒一个等待线程, 这种情况下, 若没有重新检查, 等待线程会继续认为条件改变了, 而实际上没变. 
因此将唤醒视为某物可能变了的暗示, 而非绝对的事实, 这样更安全.

注意，有时候线程之间不用条件变量和锁，用一个标记变量会看起来很简单.
例如，我们可以重写上面的等待代码:
```c
while (ready == 0)
      ; // spin
```
相关的发信号代码看起来像这样:
```c
ready = 1;
```

千万别这么干, 原因有以下几点:
首先, 许多场合下, 这种方法表现很差.(自旋很长时间只是浪费CPU时钟周期).
其次, 很容易出错. 用flags(如上)来进行线程间同步非常容易出错. 
不要偷懒，就算你觉得以不用条件变量, 也不行. 忘记那种flag的同步方法.

## 27.5 编译和运行

本章所有代码很容易运行。代码需要包括头文件 pthread.h 才能编译。链接时需要 pthread库，增加-pthread 标记。
例如，要编译一个简单的多线程程序，只需像下面这样做：
`gcc -o main main.c -Wall -pthread`
只要 main.c 包含 pthreads 头文件，你就已经成功地编译了一个并发程序.

## 27.6 小结

我们介绍了基本的 pthread 库，包括线程创建，通过锁创建互斥执行，通过条件变量的信号和等待。要想写出健壮高效的多线程代码，只需要耐心和万分小心！

本章结尾我们给出编写一些多线程代码的建议（参见补充内容）。API 的其他方面也很有趣。如果需要更多信息，请在 Linux 系统上输入 man -k pthread，查看构成整个接口的超过一百个 API。但是，这里讨论的基础知识应该让你能够构建复杂的（并且希望是正确的和高性能的）多线程程序。线程难的部分不是 API，而是如何构建并发程序的棘手逻辑。请继续阅读以了解更多信息。

>补充：线程 API 指导

当你使用 POSIX 线程库（或者实际上，任何线程库）来构建多线程程序时，需要记住一些小而重要的事情：

- 保持简洁。最重要的一点，线程之间的锁和信号的代码应该尽可能简洁。复杂的线程交互容易产生缺陷。
- 让线程交互减到最少。尽量减少线程之间的交互。每次交互都应该想清楚，并用验证过的、正确的方法来实现（很多方法会在后续章节中学习）。
- 初始化锁和条件变量。未初始化的代码有时工作正常，有时失败，会产生奇怪的结果。
- 检查返回值。当然，任何 C 和 UNIX 的程序，都应该检查返回值，这里也是一样。否则会导致古怪而难以理解的行为，让你尖叫，或者痛苦地揪自己的头发。
- 注意传给线程的参数和返回值。具体来说，如果传递在栈上分配的变量的引用，可能就是在犯错误。
- 每个线程都有自己的栈。类似于上一条，记住每一个线程都有自己的栈。因此，线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置。
- 线程之间总是通过条件变量发送信号。切记不要用标记变量来同步。
- 多查手册。尤其是 Linux 的 pthread 手册，有更多的细节、更丰富的内容。请仔细阅读！