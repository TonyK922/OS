# OSTEP

## Ch4 抽象: 进程

实现 CPU 的虚拟化, 要实现得好, 操作系统就需要一些低级机制以及一些高级智能. 

低级机制称为`机制`(mechanism). 机制是一些低级方法或协议, 实现了所需的功能. 
例如, 我们稍后将学习如何实现上下文切换(context switch).

>时分共享(time sharing)是操作系统共享资源所使用的最基本的技术之一. 通过允许资源由一个实体使用一小段时间, 然后由另一个实体使用一小段时间, 如此下去, 所谓的资源(例如, CPU 或网络链接)可以被许多人共享. 时分共享的自然对应技术是空分共享, 资源在空间上被划分给希望使用它的人. 例如, 磁盘空间自然是一个空分共享资源, 因为一旦将块分配给文件, 在用户删除文件之前, 不可能将它分配给其他文件.

在`机制`之上, 操作系统中有一些`智能`以`策略(policy)`的形式存在. 

策略是在操作系统内做出某种决定的算法. 
操作系统中的调度策略(scheduling policy)会做出这样的决定, 可能利用历史信息(例如, 哪个程序在最后一分钟运行得更多?)、工作负载知识(例如, 运行什么类型的程序?)以及性能指标 (例如, 系统是否针对交互式性能或吞吐量进行优化?)来做出决定. 

### 4.1 抽象: 进程

操作系统为正在运行的程序提供的抽象, 就是所谓的进程(process). 
一个进程只是一个正在运行的程序. 在任何时刻, 我们都可以清点它在执行过程中访问或影响的系统的不同部分, 从而概括一个进程. 

进程的机器状态有一个明显组成部分, 就是它的内存. 指令存在内存中. 正在运行的
程序读取和写入的数据也在内存中. 因此进程可以访问的内存(称为地址空间, address space)是该进程的一部分. 

进程的机器状态的另一部分是寄存器. 许多指令明确地读取或更新寄存器, 因此显然, 
它们对于执行该进程很重要. 
有一些非常特殊的寄存器构成了该机器状态的一部分. 例如, 程序计数器(Program Counter, PC)(有时称为指令指针, Instruction Pointer 或 IP)告诉我们程序当前
正在执行哪个指令; 类似地, 栈指针(stack pointer)和相关的帧指针(frame pointer)用于管理函数参数栈、局部变量和返回地址. 

程序也经常访问持久存储设备. 此类 I/O 信息可能包含当前打开的文件列表. 

### 4.2 进程API

所有现代操作系统都以某种形式提供这些 API. 
- 创建(create): 操作系统必须包含一些创建新进程的方法. 在 shell 中键入命令或双击应用程序图标时, 会调用操作系统来创建新进程, 运行指定的程序. 
- 销毁(destroy): 由于存在创建进程的接口, 因此系统还提供了一个强制销毁进程的接口. 当然, 很多进程会在运行完成后自行退出. 但是, 如果它们不退出, 用户可能希望终止它们, 因此停止失控进程的接口非常有用. 
- 等待(wait): 有时等待进程停止运行是有用的, 因此经常提供某种等待接口. 
- 其他控制(miscellaneous control): 除了杀死或等待进程外, 有时还可能有其他控制. 例如, 大多数操作系统提供某种方法来暂停进程(停止运行一段时间), 然后恢复(继续运行). 
- 状态(statu): 通常也有一些接口可以获得有关进程的状态信息, 例如运行了多长时间, 或者处于什么状态. 

### 4.3 进程创建细节

程序如何转化为进程,  具体来说, 操作系统如何启动并运行一个程序?进程创建实际如何进行?

操作系统运行程序必须做的第一件事是`将代码和所有静态数据`(例如初始化变量)`加载(load)到内存中, 加载到进程的地址空间中`. 程序最初以某种可执行格式驻留在磁盘上
(disk或者SSD上). 因此, 将程序和静态数据加载到内存中的过程, 需要操作系统从磁盘读取这些字节, 并将它们放在内存中的某处.
![](assets/Pasted%20image%2020230324174335.png)

在早期的(或简单的)操作系统中, 加载过程尽早(eagerly)完成, 即在运行程序之
前`全部`完成. 现代操作系统惰性(lazily)执行该过程, 即仅在程序执行期间`需要`加载的代码或数据片段, 才会加载. 要真正理解代码和数据的惰性加载是如何工作的, 必须更多地
了解分页和交换的机制, 这是我们将来讨论内存虚拟化时要涉及的主题. 现在, 只要记住
在运行任何程序之前, 操作系统显然必须做一些工作, 才能将重要的程序字节从磁盘读入
内存. 

将`代码和静态数据加载到内存后`, 操作系统在运行此进程之前还需要执行其他一些操作. 必须`为程序的运行时栈(run-time stack 或 stack)分配一些内存`. 你可能已经知道, C程序使用栈存放局部变量、函数参数和返回地址. 操作系统分配这些内存, 并提供给进程. 操作系统也可能会用参数初始化栈. 具体来说, 它会将参数填入 main()函数, 即 argc 和 argv数组. 

`操作系统也可能为程序的堆(heap)分配一些内存`. 在 C 程序中, 堆用于显式请求的
动态分配数据. 程序通过调用 malloc()来请求这样的空间, 并通过调用 free()来明确地释放
它. 数据结构(如链表、散列表、树等数据结构)需要堆. 起初堆会很小. 随着程序运行, 通过 malloc()库 API 请求更多内存, 操作系统可能会参与分配更多内存给进程, 以满足这些调用. 

操作系统还将`执行一些其他初始化任务`, 特别是与输入/输出(I/O)相关的任务. 例如, 
在 UNIX 系统中, 默认情况下每个进程都有 3 个打开的文件描述符(file descriptor), 用于标准输入、输出和错误. 这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕. 在本书的第 3 部分关于持久性(persistence)的知识中, 我们将详细了解 I/O、文件描述符等. 

`通过将代码和静态数据加载到内存中, 通过创建和初始化栈以及执行与 I/O 设置相关的其他工作`, OS 现在(终于)为程序执行搭好了舞台. 然后它有最后一项任务: `启动程序, 在入口处运行, 即 main()`. 通过跳转到 main()例程, OS 将 CPU的控制权转移到新创建的进程中, 从而程序开始执行. 

>加载可执行文件的各个段到进程的内存地址空间-> 创建和初始化栈内存,  可能的堆内存-> 其他初始化(I/O等任务)-> 调用main函数-> OS把CPU控制器转移到新建的进程. 

### 4.4 进程状态

进程在给定时间可能处于的不同状态(state).

- 运行(running): 在运行状态下,  进程正在处理器上运行. 它正在占用CPU, 执行指令. 
- 就绪(ready): 在就绪状态下, 进程已准备好运行, 但由于某种原因, 操作系统选择不在此时运行. 
- 阻塞(blocked): 在阻塞状态下, 一个进程执行了某种操作, `直到发生其他事件时`才会`准备运行`. 一个常见的例子是, 当进程向磁盘发起 I/O 请求时, 它会被阻塞, 因此其他进程可以使用处理器. 
![](assets/Pasted%20image%2020230324180414.png)
根据操作系统的载量, 让进程在就绪状态和运行状态之间转换. 从就绪到运行意味着该进程已经被调度(scheduled). 从运行转移到就绪意味着该进程已经取消调度(descheduled). 一旦进程被阻塞(例如,  通过发起 I/O 操作),  OS将保持进程的这种状态,  直到发生某种事件(例如,  I/O完成). 此时,  进程再次转入就绪状态(也可能立即再次运行,  如果操作系统这样决定).

### 4.5 数据结构

操作系统是一个程序, 和其他程序一样, 它有一些关键的数据结构来跟踪各种相关的信息. 

为了跟踪每个进程的状态, 操作系统可能会为`所有就绪的进程`保留某种`进程列表`(process list). 以及跟踪`当前正在运行的进程的一些附加信息`. 操作系统还必须以某种方式跟踪被阻塞的进程. 当 I/O 事件完成时, 操作系统应确保唤醒正确的进程, 让它准备好再次运行. 

对于停止的进程, 寄存器上下文将保存其寄存器的内容. 当一个进程停止时, 它的寄存器将被保存到这个`内存位置`. 
通过恢复这些寄存器(将它们的值放回实际的物理寄存器中), 操作系统可以恢复运行该进
程. 我们将在后面的章节中更多地了解这种技术,  它被称为上下文切换(context switch). 

除了运行、就绪和阻塞之外, 还有其他一些进程可以处于的状态. 有时候系统会有一个初始(initial)状态, 表示`进程在创建时处于的状态`. 另外, 一个进程可以处于已退出但尚未清理的最终(final)状态(在基于 UNIX 的系统中, 这称为`僵尸状态`). 这个最终状态非常有用, 因为它允许其他进程(通常是创建进程的父进程)检查进程的返回代码, 并查看刚刚完成的进程是否成功执行(通常, 在基于 UNIX 的系统中, 程序成功完成任务时返回零, 否则返回非零). 完成后, 父进程将进行最后一次调用(例如, wait()), 以等待子进程的完成, 并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构. 

## Ch5 插叙:  进程API

### 5.1 fork()系统调用

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int
main(int argc,  char *argv[])
{
    printf("hello world (pid: %d)\n",  (int) getpid()); 
    int rc = fork(); 
    if (rc < 0) {
        // fork failed;  exit
        fprintf(stderr,  "fork failed\n"); 
        exit(1); 
    } else if (rc == 0) {
        // child (new process)
        printf("hello,  I am child (pid: %d)\n",  (int) getpid()); 
    } else {
        // parent goes down this path (original process)
        printf("hello,  I am parent of %d (pid: %d)\n", 
	       rc,  (int) getpid()); 
    }
    return 0; 
}
```
fork() 之后,   出现父子两个进程,  子进程COPY父进程,  子进程在自己的进程里 rc是0, 所以子进程进入(rc == 0)分支运行,  父进程得到子进程的PID,  是大于0的,  所以进入else分支执行. 
所以,  上面的代码运行结果是打印 hello world,  打印 i am parent,  打印 i am child. 
至于父进程先运行,  还是子进程先运行,  看内核的调度算法.

### 5.1 wait()系统调用

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int
main(int argc,  char *argv[])
{
    printf("hello world (pid: %d)\n",  (int) getpid()); 
    int rc = fork(); 
    if (rc < 0) {
        // fork failed;  exit
        fprintf(stderr,  "fork failed\n"); 
        exit(1); 
    } else if (rc == 0) {
        // child (new process)
        printf("hello,  I am child (pid: %d)\n",  (int) getpid()); 
	sleep(1); 
    } else {
        // parent goes down this path (original process)
        int wc = wait(NULL); 
        printf("hello,  I am parent of %d (wc: %d) (pid: %d)\n", 
	       rc,  wc,  (int) getpid()); 
    }
    return 0; 
}
```
父进程调用 wait(), 延迟自己的执行, 直到子进程执行完毕. 当子进程结束谁, wait()才返回父进程. 因此输出结果也变得确定了.
上面代码,  会先打印前hello world,  再打印 i am child,  打印完child,  停顿一下,  父进程再打印i am parent.

### 5.3 exec()系统调用

这个系统调用可以让子进程执行与父进程我同的程序.
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int
main(int argc,  char *argv[])
{
    printf("hello world (pid: %d)\n",  (int) getpid()); 
    int rc = fork(); 
    if (rc < 0) {
        // fork failed;  exit
        fprintf(stderr,  "fork failed\n"); 
        exit(1); 
    } else if (rc == 0) {
        // child (new process)
        printf("hello,  I am child (pid: %d)\n",  (int) getpid()); 
        char *myargs[3]; 
        myargs[0] = strdup("wc");    // program:  "wc" (word count)
        myargs[1] = strdup("p3.c");  // argument:  file to count
        myargs[2] = NULL;            // marks end of array
        execvp(myargs[0],  myargs);   // runs word count
        printf("this shouldn't print out"); 
    } else {
        // parent goes down this path (original process)
        int wc = wait(NULL); 
        printf("hello,  I am parent of %d (wc: %d) (pid: %d)\n", 
	       rc,  wc,  (int) getpid()); 
    }
    return 0; 
}
```
子进程调用 execvp()来运行字符计数程序 wc. 事实上, 它针对源代码文件 p3.c 运行 wc, 从而告诉我我该文件有多少行、多少单词, 以及多少字节. 

给定可执行程序的名称(如 wc)及需要的参数(如 p3.c)后, `exec()会从可执行程序中加载代码和静态数据, 并用它覆写自己的代码段(以及静态数据), 堆、栈及其他内存空间也会被重新初始化. `然后操作系统就执行该程序, 将参数通过 argv 传递给该进程. 因此, 它`并没有创建新进程`, 而是`直接将当前运行的程序(以前的 p3)替换为不同的运行程(wc)`. 子进程执行 exec()之后, 几乎就像p3.c 从未运行过一样. 对 exec()的成功调用永远不会返回. 

### 5.4 为何这样设计API

为何设计如此奇怪的接口, 来完成简单的、创建新进程的任务?事实证明, 这种分离 fork()及 exec()的做法在构建 UNIX shell 的时候非常有用, 因为这给了 shell 在 fork 之后 exec 之前运行代码的机会, 这些代码可以在运行新程序前改变环境, 从而让一系列有趣的功能很容易实现. 

shell 也是一个用户程序, 它首先显示一个提示符(prompt), 然后等待用户输入. 你可以向它输入一个命令(一个可执行程序的名称及需要的参数),  大多数情况下, shell 可以在文件系统中找到这个可执行程序, 调用 fork()创建新进程, 并调用 exec()家族的函数来执行这个可执行程序,  调用 wait()等待该命令完成. 子进程执行结束后, shell 从 wait()返回并再次输出一个提示符, 等待用户输入下一条命令.
fork()和 exec()的分离, 让 shell 可以方便地实现很多有用的功能. 比如: 
`$ wc p3.c > newfile.txt`
上面的例子中, wc 的输出结果被重定向(redirect)到文件 newfile.txt 中(通过newfile.txt之前的大于号来指明重定向). shell 实现结果重定向的方式也很简单, 当完成子进程的创建后, `shell 在调用 exec()之前先关闭了标准输出(standard output)`,  打开了文件newfile.txt.
这样,  即将运行的程序 wc 的输出结果就被发送到该文件,  而不是打印在屏幕上.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/wait.h>

int
main(int argc,  char *argv[])
{
    pid_t rc ; 
    if ((rc = fork()) < 0) {
        // fork failed;  exit
        fprintf(stderr,  "fork failed\n"); 
        exit(1); 
    } else if (rc == 0) {
	// child:  redirect standard output to a file
	close(STDOUT_FILENO);  
	open("./p4.output",  O_CREAT|O_WRONLY|O_TRUNC,  S_IRWXU); 

	// now exec "wc"...
        char *myargs[3]; 
        myargs[0] = strdup("wc");    // program:  "wc" (word count)
        myargs[1] = strdup("p4.c");  // argument:  file to count
        myargs[2] = NULL;            // marks end of array
        execvp(myargs[0],  myargs);   // runs word count
    } else {
        // parent goes down this path (original process)
        int wc = wait(NULL); 
	    assert(wc >= 0); 
    }
    return 0; 
}
```

**`重定向的工作原理, 是基于对操作系统管理文件描述符方式的假设. 具体来说, UNIX 系统从打开文件描述符的0开始寻找可以使用的文件描述符. `**
上面的例子中, STDOUT_FILENO 将成为第一个可用的文件描述符, 因此在 open()被调用时, 得到赋值. 然后子进程向标准输出文件描述符的写入(例如通过 printf()这样的函数), 都会被透明地转向新打开的文件, 而不是屏幕. 

UNIX 管道也是用类似的方式实现的,  但用的是 pipe()系统调用. 在这种情况下,  一个进程的输出被链接到了一个内核管道(pipe)上(队列), 另一个进程的输入也被连接到了同一个管道上. 因此, 前一个进程的输出无缝地作为后一个进程的输入, 许多命令可以用这种方式串联在一起, 共同完成某项任务. 比如通过将 grep、wc 命令用管道连接可以完成从一个文件中查找某个词, 并统计其出现次数的功能: `grep -o foo file | wc -l` .

>补充: RTFM —— 阅读 man 手册

### 5.5 其他 API

除了上面提到的 fork()、exec()和 wait()之外, 谁 UNIX 中还有其他许多与进程交互的方式. 比如可以通过 kill()系统调用向进程发送信号(signal), 包括要求进程睡眠、终止或其他有用的指令. 实实上, 整个信号子系统提供了一套丰富的向进程传递外部事件的途径, 包括接受和执行这些信号. 

此外还有许多非常有用的命令行工具. 比如通过 ps 命令来查看当前谁运行的进程, 阅读 man 手册来了解 ps 命令所接受的参数. 工具 top 也很有用, 它展示当前系统中进程消耗CPU 或其他资源的情况. 有趣的是, 你常常会发现 top 命令自己就是最占用资源的, 它或许有一点自大狂. 此外还有许多 CPU 检测工具, 让你方便快速地了解系统负载. 比如, 我我总是让 MenuMeters(来自 Raging Menace 公司)运行谁 Mac 计算机的工具栏上, 这样就能随谁了解当前的 CPU 利用率. 一般来说, 对现状了解得越多越好. 

## Ch6 机制:  受限直接执行

为了虚拟化 CPU, 操作系统需要以某种方式让许多任务共享物理 CPU, 让它们看起来像是同时运行. 基本思想很简单: 运行一个进程一段时间, 然后运行另一个进程, 如此轮换. 通过以这种方式`时分共享(time sharing)`CPU, 就实现了虚拟化. 

然而会出现以下几个问题:  
第一个是`性能`: 如何在不增加系统开销的情况下实现虚拟化?
第二个是`控制权`: 如何有效地运行进程,  同时保留对 CPU 的控制?控制权对于操作系统尤为重要,  因为操作系统负责资源管理. 如果没有控制权,  一个进程可以简单地无限制运行并接管机器,  或访问没有权限的信息. 因此, 在保持控制权的同时获得高性能, 这是构建操作系统的主要挑战之一.

> 操作系统必须以高性能的方式虚拟化 CPU, 同时保持对系统的控制. 为此, 需要`硬件`和`操作系统`支持. 操作系统通常会明智地利用硬件支持, 以便高效地实现其工作. 

### 6.1 基本技巧: 受限直接执行

为了使程序尽可能快地运行, 操作系统开发人员想出了一种技术——我们称之为受限的直接执行(limited direct execution).
直接执行:  直接在CPU上运行程序. 因此, 当 OS 希望启动程序运行时, 它会在进程列表中为其创建一个进程条目, 为其分配一些内存, 将程序代码(从磁盘)加载到内存中, 找到入口点(main()函数或类似的), 跳转到那里, 并开始运行用户的代码. 
![](assets/Pasted%20image%2020230326201006.png)
表 6.1 展示了不受限时,  基本的直接执行协议,  使用正常的调用并返回跳转到程序的 main(), 并在稍后回到内核. 

不受限直接运行的问题在于:  
- 如果我们只运行一个程序, 操系统怎么能确保程序不做任何我们不希作望它做的事, 同时仍然高效地运行它?
- 当我们运行一个进程时, 操作系统如何让它停下来并切换到另一个进程, 从而实现虚拟化 CPU 所需的时分共享?

> 如果对运行程序没有限制, 操作系统将无法控制任何事情, 因此会成为“仅仅是一个库”.

### 6.2 问题 1: 受限制的操作

直接执行的明显优势是快速. 该程序直接在硬件 CPU 上运行,  因此执行速度与预期的一样快. 
问题在于,  如果进程希望执行某种受限操作(如向磁盘发出 I/O 请求或获得更多系统资源(如 CPU 或内存)), 该怎么办?

>提示: 采用受保护的控制权转移
  `硬件`通过`提供不同的执行模式`来协助操作系统. 在用户模式(user mode)下, 应用程序不能完全访问硬件资源. 在内核模式(kernel mode)下, 操作系统可以访问机器的全部资源. 还提供了陷入(trap)内核和从陷阱返回(return-from-trap)到用户模式程序的特别说明, 以及一些指令, 让操作系统告诉硬件陷阱表(trap table)在内存中的位置. (X86 ARM的硬件不同)

用户模式(用户态) 下,  运行的程序会有限制. 如在用户模式下运行时, 进程不能发出 I/O 请求.
内核模式(内核态)下,  由于OS是硬件唯一信任的软件,  所以内核态有权限做用户态不能做的事. 操作系统(或内核)就以这种模式运行.

用户态的程序如何,  做只有内核态才能做的操作呢? 为了实现这一点, 几乎所有的现代`硬件`都提供了用户程序执行`系统调用`的能力.

系统调用是在Atlas等古老机器上开创的, 它允许内核小心地向用户程序提供某些关键功能, 例如访问文件系统、创建和销毁进程、与其他进程通信, 以及分配更多内存. 大多数操作系统提供几百个调用(POSIX 标准). 早期的 UNIX 系统公开了更简洁的子集, 大约 20 个调用. 

要执行系统调用, 程序必须执行特殊的陷阱(trap)指令. 该指令同时跳入内核并将`特权级`别提升到内核模式. 一旦进入内核, 系统就可以执行任何需要的特权操作(如果允许), 从而为调用进程执行所需的工作. 
完成后, 操作系统调用一个特殊的从陷阱返回(return-from-trap)指令, 如你期望的那样, 该指令返回到发起调用的用户程序中, 同时将特权级别降低, 回到用户模式. 

> linux 0.11的实现 就是以INT 80 这个软中断来实现系统调用的.

执行陷阱时, 硬件需要小心, 因为它必须确保存储足够的调用者寄存器, 以便在操作系统发出从陷阱返回指令时能够正确返回.

> 在 x86 上, 处理器会将用户态程序的程序计数器、标志和其他一些寄存器压到到每个进程的内核栈(kernel stack)上. 从内核态返回用户态时,  将从栈弹出这些值, 并恢复执行用户模式程序.  ARM等其他架构具体实现不同,  但理念是一样的.

- 系统调用与过程调用(函数调用)
	系统调用的确很像函数调用,  但不同的是有些操作,  是由C库实现系统调用的. C 库中进行系统调用的部分是用汇编写的. 因为它们需要按照硬件CPU的体系结构来写, 以便正确处理参数和返回值, 以及执行硬件特定的trap指令. 

通过系统调用,  陷入内核态时,  根据传进来的参数(用寄存器传的),   会去调用 内核启动时初始化的系统调用表,  找到要执行的函数.(boot载入OS内核就把特权级转到内核态了,  所以有权限.)
操作系统做的第一件事, 就是告诉硬件在发生某些异常事件时要运行哪些代码.(初始化中断向量表). 比如发生硬盘中断,  键盘中断或程序进行系统调用等,  应该运行那些代码?
操作系统通常通过某种特殊的指令, 通知硬件这些陷阱处理程序的位置. 一旦硬件被通知, 它就会记住这些处理程序的位置, 直到下一次重新启动机器, 并且硬件知道在发生系统调用和其他异常事件时要做什么(即跳转到哪段代码). 
用一张表来表示从上到下的时间线,  假设每个进程都有一个内核栈, 在进入内核和离开内核时, 寄存器(包括通用寄存器和程序计数器)分别被保存和恢复. 
![](assets/Pasted%20image%2020230326210122.png)
上面,  LDE协议有两个阶段: 
第一个阶段(在系统引导时), 内核初始化陷阱表, 并且 CPU 记住它的位置以供随后使用. 内核通过特权指令来执行此操作.
第二个阶段(运行进程时), 在使用从陷阱返回指令开始执行进程之前, 内核设置了一些内容(例
如, 在进程列表中分配一个节点, 分配内存). 这会将 CPU 切换到用户模式并开始运行该进程. 
当进程希望发出系统调用时, 它会重新陷入操作系统, 然后再次通过从陷阱返回, 将控制权还给
进程. 该进程然后完成它的工作, 并从 main()返回. 这通常会返回到一些存根代码, 它将正确退
出该程序(例如, 通过调用 exit()系统调用, 这将陷入 OS 中). 此时, OS 清理干净, 任务完成了. 

### 6.3 问题 2: 在进程之间切换

如果一个用户的进程在 CPU 上运行, 这就意味着操作系统没有运行. 
关键问题就来了:  操作系统如何重新获得 CPU 的控制权(regain control), 以便它可以在进程之间切换?

- 协作方式: 等待系统调用

这是过去某些系统采用的一种方式. 运行时间过长的进程被假定会定期放弃 CPU, 以便操作系统可以决定运行其他任务. 进程通过进行系统调用, 将 CPU 的控制权转移给操作系统.
例如打开文件并随后读取文件, 或者向另一台机器发送消息或创建新进程. 像这样的系统通常包括一个显式的 `yield` 系统调用, 它什么都不干, 只是将控制权交给操作系统, 以便系统可以运行其他进程. 

如果应用程序执行了某些非法操作(即异常), 也会将控制转移给操作系统. 例如, 如果应用程序以 0 为除数, 或者尝试访问应该无法访问的内存, 就会陷入(trap)操作系统. 操作系统将再次控制 CPU(并可能终止违规进程). 

因此, 在协作调度系统中, OS 通过等待系统调用, 或某种非法操作发生, 从而重新获得CPU的控制权. 
问题来了,  如果不系统调用,  从而把CPU资源返回给OS的话,  就完蛋了.

- 非协作方式:  操作系统进行控制

若是没有硬件的额外帮助, 如果进程拒绝进行系统调用(也不出错), 从而将控制权交还给操作系统, 那么操作系统无法做任何事情. 
在协作方式中, 当进程陷入无限循环时, 唯一的办法就是——重启大法. 

关键问题来了: 如何在没有协作的情况下获得控制权. 假设进程不协作, 操作系统如何获得CPU的控制权?操作系统怎么来确保流氓进程不会永远占用机器?

答案是,  *时钟中断(timer interrupt)*. 
*时钟设备*可以编程为每隔几毫秒产生一次中断. 产生中断时, 当前正在运行的进程停止, 操作系统中`预先配置`的中断处理程序(interrupt handler)会运行. 此时, 操作系统重新获得 CPU 的控制权, 因此可以做它想做的事: 停止当前进程, 并启动另一个进程. 

>即使进程以非协作的方式运行, 添加时钟中断(timer interrupt)也让操作系统能够在 CPU 上重新运行. 因此, 该`硬件功能`对于帮助操作系统维持机器的控制权至关重要. 

操作系统必须通知硬件哪些代码在发生时钟中断时运行. 因此, 在启动时, 操作系统就是这样做的. 其次, 在启动过程中, 操作系统也必须`启动时钟`, 这当然是一项特权操作. 

`硬件`在发生中断时有一定的责任, 尤其是在中断发生时, 要为正在运行的程序保存足够的状态, 以便随后从陷阱返回指令能够正确恢复正在运行的程序. 这一组操作与硬件在显式系统调用陷入内核时的行为非常相似, 其中各种寄存器因此被保存(进入内核栈), 因此从陷阱返回指令可以容易地恢复. 

- 保存和恢复上下文

既然操作系统已经重新获得了控制权, 无论是通过系统调用协作, 还是通过时钟中断更强制执行, 都必须决定: 是继续运行当前正在运行的进程, 还是切换到另一个进程. 这个决定是由调度程序(scheduler)做出的, 它是操作系统的一部分. 

若是决定进行切换, OS 就会执行一些底层代码, 即所谓的上下文切换(context switch), 即为当前正在执行的进程保存一些寄存器的值(例如, 到它的内核栈), 并为即将执行的进程恢复一些寄存器的值(从它的内核栈). 
这样一来, 操作系统就可以确保最后执行从陷阱返回指令时, 不是返回到之前运行的进程, 而是继续执行另一个进程.

为了保存当前正在运行的进程的上下文, 操作系统会执行一些底层汇编代码来保存通用寄存器、程序计数器, 以及当前正在运行的进程的内核栈指针, 然后恢复寄存器、程序计数器, 并切换内核栈, 供即将运行的进程使用. 
通过切换栈, 内核在`进入切换代码调用时`, 是一个进程(被中断的进程)的上下文, 在`返回时`, 是另一进程(即将执行的进程)的上下文. 当操作系统最终执行从陷阱返回指令时, 即将执行的进程变成了当前运行的进程. 至此上下文切换完成. 

![](assets/Pasted%20image%2020230326213609.png)
上面时间线表示了进程A,  切到进程B的过程. 时钟中断触发,  进程A的现场被压在内核栈中,  然后调用switch(),  把进程A的现场保存在内核PCB结构体变量中,  同时把B从PCB变量恢复到寄存器,  恢复B进程的现场. 跳转运行.
有两种类型的寄存器保存/恢复. 
第一种是发生时钟中断的时候. 在这种情况下, 运行进程的用户寄存器由硬件隐式保存, 使用该进程的内核栈. 
第二种是当操作系统决定从 A 切换到 B. 在这种情况下, 内核寄存器被软件(即 OS)明确地保存, 但这次被存储在该进程的进程结构的内存中. 后一个操作让系统从好像刚刚由 A 陷入内核, 变成好像刚刚由 B 陷入内核. 

```asm
# void swtch(struct context **old,  struct context *new); 
#
# Save current register context in old
# and then load register context from new.
.globl swtch
swtch: 
# Save old registers
movl 4(%esp),  %eax # put old ptr into eax
popl 0(%eax) # save the old IP
movl %esp,  4(%eax) # and stack
movl %ebx,  8(%eax) # and other registers
movl %ecx,  12(%eax)
movl %edx,  16(%eax)
movl %esi,  20(%eax)
movl %edi,  24(%eax)
movl %ebp,  28(%eax)

# Load new registers
movl 4(%esp),  %eax # put new ptr into eax
movl 28(%eax),  %ebp # restore other registers
movl 24(%eax),  %edi
movl 20(%eax),  %esi
movl 16(%eax),  %edx
movl 12(%eax),  %ecx
movl 8(%eax),  %ebx
movl 4(%eax),  %esp # stack is switched here
pushl 0(%eax) # return addr put in place
ret # finally return into new ctxt
```
这段汇编就是x86体系,  xv6内核切换上下文的.

### 6.4 小结

受限直接执行:  基本思路很简单: 就让你想运行的程序在 CPU 上运行, 但首先确保设置好硬件, 以便在没有操作系统帮助的情况下限制进程可以执行的操作.
分内核态和用户态,  用户态的特权级有限. 内核态的特权级最高. 用户态到内核态,  就用系统调用,  或者其他方式触发.

内核从用户态进程获得CPU资源的方法:  由进程系统调用让出CPU资源,  或由时钟中断强行切换.